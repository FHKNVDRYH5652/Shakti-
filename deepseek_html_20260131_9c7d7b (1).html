<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mickey X Web - Smart Wingo Predictor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    
    <style>
        :root {
            --neon-purple: #bc13fe;
            --neon-glow: #d670ff;
            --hacker-green: #00ff41;
            --matrix-green: #0aff0a;
            --dark-bg: #0a0a0a;
            --terminal-bg: #001100;
            --card-bg: rgba(0, 40, 0, 0.7);
            --green: #00ff00;
            --red: #ff0000;
            --gold: #ffcc00;
            --orange: #ff9900;
            --violet: #9d00ff;
            --teal: #00ffcc;
            --pink: #ff00aa;
            --yellow: #ffff00;
            --cyan: #00ffff;
            --button-blue: #0066ff;
            --button-glow: #00aaff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Rajdhani', sans-serif; user-select: none; }
        body { 
            background: linear-gradient(45deg, #000000, #001100, #000a00, #000000);
            color: white; 
            overflow-x: hidden; 
            min-height: 100vh;
            position: relative;
        }
        
        /* Matrix Code Rain Background */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: #000;
            overflow: hidden;
        }
        
        .matrix-column {
            position: absolute;
            top: -100px;
            color: var(--hacker-green);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 5px var(--hacker-green), 0 0 10px var(--hacker-green);
            white-space: nowrap;
            animation: matrixFall linear infinite;
        }
        
        @keyframes matrixFall {
            0% {
                transform: translateY(-100%);
                opacity: 0;
            }
            5% {
                opacity: 1;
            }
            95% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
        
        /* Binary Particles */
        #binary-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        
        .binary-particle {
            position: absolute;
            color: var(--matrix-green);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            opacity: 0;
            animation: binaryFloat linear infinite;
            text-shadow: 0 0 8px var(--matrix-green);
        }
        
        @keyframes binaryFloat {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) translateX(20px);
                opacity: 0;
            }
        }
        
        /* Terminal Scan Line */
        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, 
                transparent, 
                var(--hacker-green), 
                var(--matrix-green), 
                var(--hacker-green), 
                transparent);
            box-shadow: 0 0 15px var(--hacker-green);
            animation: scanMove 4s linear infinite;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.7;
        }
        
        @keyframes scanMove {
            0% {
                top: 0%;
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
            100% {
                top: 100%;
                opacity: 0.7;
            }
        }
        
        /* Landing Page */
        #landing-page { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .main-title { 
            font-family: 'Orbitron', sans-serif; 
            font-size: 3rem; 
            color: var(--hacker-green); 
            text-shadow: 0 0 20px var(--hacker-green), 0 0 40px var(--hacker-green);
            margin-bottom: 40px; 
            text-align: center;
            padding: 20px;
            border: 2px solid var(--hacker-green);
            background: rgba(0, 30, 0, 0.3);
            backdrop-filter: blur(5px);
            animation: titleGlow 3s infinite alternate;
            position: relative;
            overflow: hidden;
        }
        
        @keyframes titleGlow {
            0% {
                box-shadow: 0 0 10px var(--hacker-green),
                            inset 0 0 10px rgba(0, 255, 65, 0.2);
                text-shadow: 0 0 10px var(--hacker-green);
            }
            100% {
                box-shadow: 0 0 30px var(--hacker-green),
                            inset 0 0 20px rgba(0, 255, 65, 0.4);
                text-shadow: 0 0 20px var(--hacker-green),
                             0 0 30px var(--hacker-green);
            }
        }
        
        .platform-scroller { 
            display: flex; 
            overflow-x: auto; 
            gap: 25px; 
            width: 100%; 
            max-width: 1300px; 
            padding: 40px 20px; 
            scroll-behavior: smooth; 
            scrollbar-width: none; 
        }
        
        .platform-scroller::-webkit-scrollbar { display: none; }
        
        .platform-card { 
            flex: 0 0 280px; 
            height: 450px; 
            background: linear-gradient(135deg, 
                rgba(0, 40, 0, 0.8), 
                rgba(0, 60, 0, 0.5), 
                rgba(0, 40, 0, 0.8)); 
            border: 2px solid var(--hacker-green); 
            border-radius: 20px; 
            position: relative; 
            overflow: hidden; 
            transition: all 0.4s ease; 
            cursor: pointer; 
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .platform-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
        }
        
        .platform-card:hover { 
            transform: scale(1.08) translateY(-15px); 
            box-shadow: 0 0 40px var(--hacker-green),
                        inset 0 0 20px rgba(0, 255, 65, 0.2);
            border-color: var(--matrix-green);
            animation: cardPulse 2s infinite;
        }
        
        @keyframes cardPulse {
            0% {
                box-shadow: 0 0 20px var(--hacker-green),
                            inset 0 0 15px rgba(0, 255, 65, 0.2);
            }
            50% {
                box-shadow: 0 0 40px var(--hacker-green),
                            inset 0 0 25px rgba(0, 255, 65, 0.3);
            }
            100% {
                box-shadow: 0 0 20px var(--hacker-green),
                            inset 0 0 15px rgba(0, 255, 65, 0.2);
            }
        }
        
        .platform-label { 
            position: absolute; 
            bottom: 0; 
            width: 100%; 
            background: linear-gradient(to top, 
                rgba(0, 30, 0, 0.95), 
                rgba(0, 50, 0, 0.7)); 
            color: var(--hacker-green); 
            text-align: center; 
            padding: 20px; 
            font-weight: bold; 
            font-size: 1.4rem; 
            border-top: 2px solid var(--hacker-green);
            text-shadow: 0 0 10px var(--hacker-green);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            z-index: 2;
        }
        
        /* Platform Description */
        .platform-desc {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 0.9rem;
            color: #fff;
        }
        
        /* Scratch Cards Page */
        #scratch-page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .scratch-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: var(--hacker-green);
            text-shadow: 0 0 15px var(--hacker-green);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .scratch-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            max-width: 800px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 768px) {
            .scratch-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .scratch-card {
            width: 180px;
            height: 240px;
            background: linear-gradient(135deg, rgba(0, 50, 0, 0.8), rgba(0, 80, 0, 0.8));
            border: 3px solid var(--hacker-green);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        
        .scratch-cover {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #666, #333);
            background-size: 400% 400%;
            animation: scratchCover 3s ease-in-out infinite;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        @keyframes scratchCover {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .scratch-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.9), rgba(0, 150, 0, 0.9));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .scratch-content.revealed {
            opacity: 1;
        }
        
        .coin-icon {
            font-size: 3rem;
            color: var(--gold);
            margin-bottom: 15px;
        }
        
        .coin-amount {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--gold);
            text-shadow: 0 0 10px var(--gold);
        }
        
        .coin-text {
            font-size: 1.2rem;
            color: white;
            margin-top: 10px;
        }
        
        .scratch-instruction {
            color: var(--hacker-green);
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1rem;
        }
        
        .coins-total {
            font-size: 1.8rem;
            color: var(--gold);
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 10px var(--gold);
        }
        
        .start-prediction-btn {
            background: linear-gradient(45deg, var(--hacker-green), var(--matrix-green));
            color: black;
            border: none;
            padding: 20px 50px;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            display: none;
            box-shadow: 0 0 20px var(--hacker-green);
        }
        
        .start-prediction-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--hacker-green);
        }
        
        /* Video Page */
        #video-page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: relative;
            z-index: 1000;
            background: black;
        }
        
        .video-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        #intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .skip-video-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            color: var(--hacker-green);
            border: 2px solid var(--hacker-green);
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s;
            z-index: 1001;
        }
        
        .skip-video-btn:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 15px var(--hacker-green);
        }
        
        /* Prediction Page */
        #prediction-page {
            display: none;
            flex-direction: column;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 30, 0, 0.5);
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid var(--hacker-green);
        }
        
        .buy-coins-btn {
            background: linear-gradient(45deg, var(--button-blue), var(--button-glow));
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.5);
        }
        
        .buy-coins-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 170, 255, 0.7);
        }
        
        .coins-display {
            font-size: 1.5rem;
            color: var(--gold);
            font-weight: bold;
            text-shadow: 0 0 10px var(--gold);
        }
        
        .uid-display {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 30, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid var(--hacker-green);
        }
        
        .uid-text {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: var(--hacker-green);
        }
        
        .copy-uid-btn {
            background: transparent;
            border: 1px solid var(--hacker-green);
            color: var(--hacker-green);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .copy-uid-btn:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        
        .main-container {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }
        
        .game-title {
            text-align: center;
            color: var(--hacker-green);
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 0 15px var(--hacker-green);
        }
        
        .game-subtitle {
            text-align: center;
            color: #aaa;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }
        
        .period-display {
            background: rgba(0, 40, 0, 0.7);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .period-label {
            color: var(--hacker-green);
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .period-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--matrix-green);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px var(--matrix-green);
            word-break: break-all;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid var(--hacker-green);
            max-width: 100%;
            overflow-wrap: break-word;
        }
        
        .period-timer {
            font-size: 0.9rem;
            color: var(--orange);
            margin-top: 8px;
        }
        
        .prediction-container {
            background: rgba(0, 30, 0, 0.5);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .prediction-cost {
            color: var(--hacker-green);
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        .cost-amount {
            color: var(--gold);
            font-weight: bold;
        }
        
        .generate-btn {
            background: linear-gradient(45deg, #ff6600, #ff3300);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            width: 100%;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .generate-btn:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 30px rgba(255, 51, 0, 0.7);
        }
        
        .generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .generate-btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .generate-btn:hover::before {
            left: 100%;
        }
        
        /* Unix Terminal Analysis Animation */
        .analysis-container {
            display: none;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            height: 300px;
            overflow: hidden;
            position: relative;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: var(--hacker-green);
            border-bottom: 1px solid var(--hacker-green);
            padding-bottom: 8px;
        }
        
        .terminal-title {
            font-size: 1rem;
            font-weight: bold;
        }
        
        .terminal-controls {
            display: flex;
            gap: 10px;
        }
        
        .terminal-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .control-close { background: #ff5f56; }
        .control-minimize { background: #ffbd2e; }
        .control-maximize { background: #27ca3f; }
        
        .terminal-body {
            height: calc(100% - 60px);
            overflow: hidden;
            position: relative;
        }
        
        .terminal-output {
            color: var(--hacker-green);
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            text-shadow: 0 0 5px var(--hacker-green);
            height: 100%;
            overflow-y: auto;
        }
        
        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: var(--hacker-green);
            animation: blink 1s infinite;
            margin-left: 2px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .graph-container {
            margin-top: 15px;
            height: 120px;
            background: rgba(0, 20, 0, 0.5);
            border: 1px solid var(--hacker-green);
            border-radius: 5px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
        }
        
        .graph-axis {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 1px;
            background: rgba(0, 255, 65, 0.5);
        }
        
        .graph-line {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            height: 1px;
            background: var(--matrix-green);
            box-shadow: 0 0 10px var(--matrix-green);
        }
        
        .graph-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--hacker-green);
            border-radius: 50%;
            transform: translate(-50%, 50%);
            box-shadow: 0 0 8px var(--hacker-green);
        }
        
        .analysis-progress {
            position: absolute;
            bottom: 10px;
            left: 20px;
            right: 20px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--hacker-green), var(--matrix-green));
            width: 0%;
            transition: width 5s linear;
            box-shadow: 0 0 10px var(--hacker-green);
        }
        
        /* Prediction Result */
        .prediction-result {
            display: none;
            background: linear-gradient(135deg, rgba(0, 60, 0, 0.9), rgba(0, 100, 0, 0.9));
            border: 3px solid var(--hacker-green);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
        }
        
        .prediction-label {
            color: var(--hacker-green);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .prediction-value {
            font-size: 3.5rem;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            margin: 15px 0;
            text-transform: uppercase;
        }
        
        .prediction-red {
            color: #ff3333;
            text-shadow: 0 0 20px #ff3333;
        }
        
        .prediction-green {
            color: #33ff33;
            text-shadow: 0 0 20px #33ff33;
        }
        
        .prediction-violet {
            color: #cc33ff;
            text-shadow: 0 0 20px #cc33ff;
        }
        
        .prediction-big {
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00;
        }
        
        .prediction-small {
            color: #00ccff;
            text-shadow: 0 0 20px #00ccff;
        }
        
        .prediction-type {
            color: var(--matrix-green);
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .prediction-note {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 15px;
            font-style: italic;
        }
        
        /* History Panel */
        .history-panel {
            background: rgba(0, 30, 0, 0.5);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .history-title {
            color: var(--hacker-green);
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid var(--hacker-green);
        }
        
        .history-period {
            font-size: 0.9rem;
            color: #aaa;
            font-family: 'Courier New', monospace;
        }
        
        .history-prediction {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .history-result {
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            min-width: 80px;
            text-align: center;
        }
        
        .pending {
            background: rgba(255, 255, 0, 0.2);
            color: #ffff00;
            border: 1px solid #ffff00;
        }
        
        .win {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        
        .loss {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
            border: 1px solid #ff0000;
        }
        
        .no-prediction {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        /* Hacker Terminal Text */
        .hacker-text {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--hacker-green);
            text-shadow: 0 0 5px var(--hacker-green);
            opacity: 0.7;
            z-index: 1;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-title {
                font-size: 2rem;
            }
            
            .platform-card {
                flex: 0 0 220px;
                height: 350px;
            }
            
            .scratch-title {
                font-size: 2rem;
            }
            
            .scratch-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
            
            .scratch-card {
                width: 150px;
                height: 200px;
            }
            
            .prediction-value {
                font-size: 2.8rem;
            }
            
            .period-number {
                font-size: 1.1rem;
            }
            
            .history-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .history-result {
                align-self: flex-end;
            }
            
            .prediction-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .uid-display {
                justify-content: center;
            }
        }
    </style>
</head>
<body>

    <!-- Matrix Code Rain Background -->
    <div id="matrix-bg"></div>
    
    <!-- Binary Particles -->
    <div id="binary-particles"></div>
    
    <!-- Terminal Scan Line -->
    <div class="scan-line"></div>
    
    <!-- Hacker Terminal Text -->
    <div class="hacker-text" id="terminal-text">
        > SYSTEM: ONLINE<br>
        > ACCESS: GRANTED<br>
        > TIME: <span id="hacker-time">00:00:00</span>
    </div>

    <!-- Landing Page -->
    <section id="landing-page">
        <h1 class="main-title">CHOOSE PLATFORM</h1>
        <div class="platform-scroller">
            <div class="platform-card" onclick="selectPlatform('TASHAN')">
                <div class="platform-desc">REAL MONEY CASINO<br>FREE CHIPS DAILY</div>
                <img src="tashan.png" alt="TASHAN" onerror="this.src='https://images.unsplash.com/photo-1561043845-2f5e09749871?w=400&h=500&fit=crop'">
                <div class="platform-label">TASHAN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('DM WIN')">
                <div class="platform-desc">FAST WITHDRAWALS<br>SAFE & SECURE</div>
                <img src="dmwin.png" alt="DM WIN" onerror="this.src='https://images.unsplash.com/photo-1518998053901-5348d3961a04?w=400&h=500&fit=crop'">
                <div class="platform-label">DM WIN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('DAMAN')">
                <div class="platform-desc">HIGH LIMITS<br>BONUS REWARDS</div>
                <img src="daman.png" alt="DAMAN" onerror="this.src='https://images.unsplash.com/photo-1633265486064-086b219458ec?w=400&h=500&fit=crop'">
                <div class="platform-label">DAMAN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('JALWA')">
                <div class="platform-desc">LIVE GAMES<br>24/7 SUPPORT</div>
                <img src="jalwa.png" alt="JALWA" onerror="this.src='https://images.unsplash.com/photo-1533105079780-92b9be482077?w=400&h=500&fit=crop'">
                <div class="platform-label">JALWA</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('82 LOTTERY')">
                <div class="platform-desc">LOTTERY GAMES<br>BIG JACKPOTS</div>
                <img src="82lottery.png" alt="82 LOTTERY" onerror="this.src='https://images.unsplash.com/photo-1589594225352-7689b5d92b3c?w=400&h=500&fit=crop'">
                <div class="platform-label">82 LOTTERY</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('BDG GAME')">
                <div class="platform-desc">CASINO GAMES<br>MULTIPLAYER</div>
                <img src="bdggame.png" alt="BDG GAME" onerror="this.src='https://images.unsplash.com/photo-1614732414444-096e5f1122d5?w=400&h=500&fit=crop'">
                <div class="platform-label">BDG GAME</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('GOA GAME')">
                <div class="platform-desc">BEACH THEME<br>SPECIAL BONUSES</div>
                <img src="goagame.png" alt="GOA GAME" onerror="this.src='https://images.unsplash.com/photo-1513814486256-9cbb0b5b73c3?w=400&h=500&fit=crop'">
                <div class="platform-label">GOA GAME</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('91 CLUB')">
                <div class="platform-desc">VIP LOUNGE<br>EXCLUSIVE REWARDS</div>
                <img src="91club.png" alt="91 CLUB" onerror="this.src='https://images.unsplash.com/photo-1536922246289-88c42f957773?w=400&h=500&fit=crop'">
                <div class="platform-label">91 CLUB</div>
            </div>
        </div>
    </section>

    <!-- Scratch Cards Page -->
    <section id="scratch-page">
        <h2 class="scratch-title">SCRATCH & WIN COINS</h2>
        <p class="scratch-instruction">Scratch all 5 cards to reveal your coins bonus!</p>
        
        <div class="coins-total">Total Coins: <span id="total-coins">0</span></div>
        
        <div class="scratch-grid">
            <!-- 5 Scratch Cards -->
            <div class="scratch-card" onclick="scratchCard(0)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-0">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-0">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(1)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-1">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-1">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(2)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-2">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-2">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(3)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-3">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-3">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(4)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-4">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-4">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
        </div>
        
        <button class="start-prediction-btn" onclick="startVideo()">CLICK TO START PREDICTION</button>
    </section>

    <!-- Video Page -->
    <section id="video-page">
        <div class="video-container">
            <video id="intro-video" autoplay playsinline>
                <source src="shakti.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <button class="skip-video-btn" onclick="skipVideo()">
                <i class="fas fa-forward"></i> SKIP VIDEO
            </button>
        </div>
    </section>

    <!-- Prediction Page -->
    <section id="prediction-page">
        <div class="prediction-header">
            <button class="buy-coins-btn" onclick="buyCoins()">
                <i class="fas fa-coins"></i> BUY COINS
            </button>
            <div class="coins-display">
                <i class="fas fa-coins"></i> <span id="available-coins">0</span> COINS
            </div>
            <div class="uid-display">
                <div class="uid-text">UID: <span id="user-uid">0000000</span></div>
                <button class="copy-uid-btn" onclick="copyUid()">
                    <i class="fas fa-copy"></i> Copy
                </button>
            </div>
        </div>
        
        <div class="main-container">
            <h2 class="game-title">WINGO 1 MIN GAME PREDICTION</h2>
            <p class="game-subtitle">Smart Algorithm Prediction System</p>
            
            <div class="period-display">
                <div class="period-label">LIVE NEXT PERIOD NUMBER</div>
                <div class="period-number" id="current-period">LOADING...</div>
                <div class="period-timer" id="period-timer"></div>
            </div>
            
            <div class="prediction-container">
                <div class="prediction-cost">
                    Prediction Cost: <span class="cost-amount">5 COINS</span> per prediction
                </div>
                
                <button class="generate-btn" id="generate-btn" onclick="generatePrediction()">
                    <i class="fas fa-bolt"></i> GENERATE PREDICTION
                </button>
                
                <!-- Unix Terminal Analysis Animation -->
                <div class="analysis-container" id="analysis-container">
                    <div class="terminal-header">
                        <div class="terminal-title">PREDICTION_ENGINE.exe</div>
                        <div class="terminal-controls">
                            <div class="terminal-control control-close"></div>
                            <div class="terminal-control control-minimize"></div>
                            <div class="terminal-control control-maximize"></div>
                        </div>
                    </div>
                    <div class="terminal-body">
                        <div class="terminal-output" id="terminal-output">
                            > Initializing prediction engine...<br>
                            > Accessing Wingo API...<br>
                            > Analyzing historical data...<br>
                            <span id="analysis-text"></span>
                            <span class="terminal-cursor"></span>
                        </div>
                        <div class="graph-container">
                            <div class="graph-axis"></div>
                            <div class="graph-canvas" id="graph-canvas"></div>
                        </div>
                    </div>
                    <div class="analysis-progress">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>
                
                <!-- Prediction Result -->
                <div class="prediction-result" id="prediction-result">
                    <div class="prediction-label">YOUR PREDICTION</div>
                    <div class="prediction-value" id="prediction-value">--</div>
                    <div class="prediction-type" id="prediction-type">--</div>
                    <div class="prediction-note">Based on advanced algorithm analysis</div>
                </div>
            </div>
            
            <!-- History Panel -->
            <div class="history-panel">
                <div class="history-title">PREDICTION HISTORY</div>
                <div id="history-items">
                    <div class="no-prediction">No predictions yet. Generate your first prediction!</div>
                </div>
            </div>
        </div>
    </section>

    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCShaI7FfDCvZ9t21RdBk7ATjk5PQUAeQI",
            authDomain: "wingo-predictor-hub.firebaseapp.com",
            databaseURL: "https://wingo-predictor-hub-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "wingo-predictor-hub",
            storageBucket: "wingo-predictor-hub.firebasestorage.app",
            messagingSenderId: "510934626240",
            appId: "1:510934626240:web:8df9c4b4a78964f15d2225",
            measurementId: "G-TTM7WXC4DW"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Global variables
        const API_URL = "https://wingolast100.vercel.app/api/results?typeId=1&apiKey=12a04165-748c-4144-9398-96bd2e0ad956&token=1a97a413-ff57-4097-a44c-4bd402ace8d5&limit=100";
        let resultsData = [];
        let currentPeriodNumber = "";
        let coins = 0;
        let scratchedCards = 0;
        let cardCoins = [0, 0, 0, 0, 0];
        let historyData = [];
        let winStreak = 0;
        let lossStreak = 0;
        let totalPredictions = 0;
        let correctPredictions = 0;
        let userId = "";
        let userUid = "";
        let lastPredictionPeriod = "";
        let currentPeriodTimer = null;
        let currentPlatform = "";
        let hasScratchedBefore = false;
        let firebaseUserRef = null;
        
        // ==================== ADVANCED WINGO PREDICTION LOGIC (FROM FIRST FILE) ====================
        // à¤¸à¤¾à¤°à¤¾ logic à¤ªà¤¹à¤²à¥‡ à¤µà¤¾à¤²à¥‡ à¤«à¤¾à¤‡à¤² à¤¸à¥‡ same to same à¤²à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾ à¤¹à¥ˆ
        
        // Advanced Wingo Algorithm Tracking Variables
        let currentAlgorithm = null;
        let algorithmHistory = [];
        let lastAlgorithmChange = 0;
        let algorithmConfidence = 0;
        let detectedPattern = [];
        let algorithmPerformance = { wins: 0, losses: 0, accuracy: 0 };
        let algorithmChangeCount = 0;
        
        // Wingo Game Strategy Analysis Variables
        let wingoGamePhase = "neutral"; // "winning", "losing", "neutral"
        let wingoPhaseConfidence = 0;
        let wingoWinStreak = 0;
        let wingoLossStreak = 0;
        let wingoPlayerWinRate = 50;
        let wingoPhaseDuration = 0;
        let wingoPhaseStartTime = Date.now();
        let wingoExpectedPhaseChange = 0;
        
        // Pattern Detection Variables
        let numberPatterns = [];
        let colorPatterns = [];
        let sizePatterns = [];
        let currentPatternIndex = 0;
        let patternCycleLength = 0;
        let algorithmChangeDetected = false;
        
        // Wingo Algorithms Database (SAME AS FIRST FILE)
        const WINGO_ALGORITHMS = {
            WIN_DISTRIBUTION: {
                name: "WIN_DISTRIBUTION",
                pattern: [1, 3, 5, 7, 9, 2, 4, 6, 8, 0],
                type: "WIN_PHASE",
                colorPattern: ["RED", "GREEN", "RED", "GREEN", "RED", "GREEN", "RED", "GREEN", "RED", "GREEN"],
                sizePattern: ["BIG", "BIG", "BIG", "BIG", "BIG", "SMALL", "SMALL", "SMALL", "SMALL", "SMALL"],
                nextNumber: 1,
                confidence: 85,
                changeFrequency: 15,
                description: "Game giving wins to attract players",
                winProbability: 0.7
            },
            LOSS_RECOVERY: {
                name: "LOSS_RECOVERY",
                pattern: [0, 5, 0, 5, 0, 5, 0, 5, 0, 5],
                type: "LOSS_PHASE",
                colorPattern: ["GREEN", "GREEN", "GREEN", "GREEN", "GREEN", "GREEN", "GREEN", "GREEN", "GREEN", "GREEN"],
                sizePattern: ["SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG"],
                nextNumber: 0,
                confidence: 80,
                changeFrequency: 12,
                description: "Game recovering losses from players",
                winProbability: 0.3
            },
            BALANCE_MAINTENANCE: {
                name: "BALANCE_MAINTENANCE",
                pattern: [1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
                type: "NEUTRAL_PHASE",
                colorPattern: ["RED", "GREEN", "RED", "GREEN", "GREEN", "RED", "RED", "GREEN", "RED", "GREEN"],
                sizePattern: ["BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL"],
                nextNumber: 1,
                confidence: 75,
                changeFrequency: 20,
                description: "Game maintaining balanced win/loss ratio",
                winProbability: 0.5
            },
            PATTERN_BREAKER: {
                name: "PATTERN_BREAKER",
                pattern: [7, 2, 9, 4, 1, 6, 3, 8, 5, 0],
                type: "RANDOMIZED",
                colorPattern: ["RED", "GREEN", "RED", "GREEN", "RED", "RED", "GREEN", "GREEN", "GREEN", "GREEN"],
                sizePattern: ["BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL", "BIG", "SMALL"],
                nextNumber: 7,
                confidence: 65,
                changeFrequency: 8,
                description: "Breaking player patterns to cause losses",
                winProbability: 0.4
            }
        };
        
        // Generate 7-digit UID
        function generateUid() {
            let uid = localStorage.getItem('wingo_user_uid');
            if (!uid) {
                uid = Math.floor(1000000 + Math.random() * 9000000).toString();
                localStorage.setItem('wingo_user_uid', uid);
            }
            return uid;
        }
        
        // Copy UID to clipboard
        function copyUid() {
            const uidText = document.getElementById('user-uid').textContent;
            navigator.clipboard.writeText(uidText).then(() => {
                alert('UID copied to clipboard: ' + uidText);
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }
        
        // Generate user ID for Firebase
        function generateUserId() {
            let id = localStorage.getItem('wingo_user_id');
            if (!id) {
                id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('wingo_user_id', id);
            }
            return id;
        }
        
        // Matrix Code Rain Effect
        function createMatrixRain() {
            const matrixBg = document.getElementById('matrix-bg');
            const chars = "01ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$+-*/=%\"'#&_(),.;:?!\\|{}<>[]^~";
            
            const columnCount = Math.floor(window.innerWidth / 20);
            
            for (let i = 0; i < columnCount; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = `${(i * 20) + Math.random() * 10}px`;
                
                let content = '';
                const charCount = Math.floor(Math.random() * 30) + 10;
                
                for (let j = 0; j < charCount; j++) {
                    content += chars[Math.floor(Math.random() * chars.length)];
                    if (j < charCount - 1) content += '<br>';
                }
                
                column.innerHTML = content;
                column.style.animationDuration = `${Math.random() * 10 + 10}s`;
                column.style.animationDelay = `${Math.random() * 5}s`;
                column.style.fontSize = `${Math.random() * 6 + 12}px`;
                column.style.opacity = Math.random() * 0.5 + 0.3;
                
                matrixBg.appendChild(column);
            }
        }
        
        // Binary Particles Effect
        function createBinaryParticles() {
            const container = document.getElementById('binary-particles');
            const binaryChars = ["0", "1"];
            
            const particleCount = 100;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'binary-particle';
                particle.textContent = binaryChars[Math.floor(Math.random() * binaryChars.length)];
                
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                const duration = Math.random() * 20 + 10;
                const delay = Math.random() * 15;
                particle.style.animationDuration = `${duration}s`;
                particle.style.animationDelay = `${delay}s`;
                
                particle.style.fontSize = `${Math.random() * 8 + 8}px`;
                
                container.appendChild(particle);
            }
        }
        
        // Update terminal time
        function updateTerminalTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            document.getElementById('hacker-time').textContent = timeString;
        }
        
        // Initialize effects
        function initializeEffects() {
            createMatrixRain();
            createBinaryParticles();
            updateTerminalTime();
            setInterval(updateTerminalTime, 1000);
        }
        
        // Select Platform
        function selectPlatform(platform) {
            currentPlatform = platform;
            
            // Check if user has already scratched cards before
            hasScratchedBefore = localStorage.getItem('wingo_has_scratched') === 'true';
            
            // Always show video when platform is selected
            // But check if scratch cards have been used before
            if (hasScratchedBefore) {
                // If already scratched before, go directly to video
                startVideo();
            } else {
                // If not scratched before, show scratch cards
                openScratchPage();
            }
        }
        
        // Open Scratch Page
        function openScratchPage() {
            document.getElementById('landing-page').style.display = 'none';
            document.getElementById('scratch-page').style.display = 'flex';
            
            // Reset scratch cards if not already scratched
            if (scratchedCards === 0) {
                resetScratchCards();
            }
        }
        
        function resetScratchCards() {
            scratchedCards = 0;
            cardCoins = [0, 0, 0, 0, 0];
            
            // Reset UI
            for (let i = 0; i < 5; i++) {
                document.getElementById(`card-${i}`).classList.remove('revealed');
                document.getElementById(`coin-${i}`).textContent = '?';
            }
            
            document.getElementById('total-coins').textContent = '0';
            document.querySelector('.start-prediction-btn').style.display = 'none';
        }
        
        function scratchCard(index) {
            if (cardCoins[index] > 0) return; // Already scratched
            
            // Generate random coins between 10 and 50 (minimum 10, maximum 50)
            const randomCoins = Math.floor(Math.random() * 41) + 10; // 10-50
            cardCoins[index] = randomCoins;
            scratchedCards++;
            
            // Update UI
            document.getElementById(`card-${index}`).classList.add('revealed');
            document.getElementById(`coin-${index}`).textContent = randomCoins;
            
            // Update total coins
            coins = cardCoins.reduce((sum, coin) => sum + coin, 0);
            document.getElementById('total-coins').textContent = coins;
            
            // If all cards scratched, show start button
            if (scratchedCards === 5) {
                setTimeout(() => {
                    document.querySelector('.start-prediction-btn').style.display = 'block';
                }, 500);
                
                // Mark that user has scratched cards before
                localStorage.setItem('wingo_has_scratched', 'true');
            }
        }
        
        function startVideo() {
            // Hide appropriate pages based on whether we came from scratch page or directly
            if (hasScratchedBefore) {
                document.getElementById('landing-page').style.display = 'none';
            } else {
                document.getElementById('scratch-page').style.display = 'none';
            }
            
            document.getElementById('video-page').style.display = 'flex';
            
            // Save coins to localStorage if we got them from scratch cards
            if (!hasScratchedBefore) {
                localStorage.setItem('wingo_coins', coins);
            } else {
                // Load existing coins if already scratched before
                coins = parseInt(localStorage.getItem('wingo_coins')) || 0;
            }
            
            // Play video
            const video = document.getElementById('intro-video');
            video.play();
            
            // Auto proceed when video ends
            video.onended = function() {
                skipVideo();
            };
        }
        
        function skipVideo() {
            document.getElementById('video-page').style.display = 'none';
            document.getElementById('prediction-page').style.display = 'flex';
            
            // Initialize prediction page
            initializePredictionPage();
        }
        
        function buyCoins() {
            window.open('https://t.me/Predict456', '_blank');
        }
        
        // ==================== ADVANCED WINGO GAME ANALYSIS (FROM FIRST FILE) ====================
        
        // Analyze Wingo game strategy (SAME AS FIRST FILE)
        function analyzeWingoGameStrategy() {
            if (!resultsData || resultsData.length < 20) {
                return {
                    phase: "neutral",
                    confidence: 0,
                    winRate: 50,
                    winStreak: 0,
                    lossStreak: 0,
                    nextPhaseChange: 0,
                    description: "Insufficient data for analysis"
                };
            }
            
            const recentResults = resultsData.slice(0, 30);
            
            // Analyze win/loss patterns from game's perspective
            let playerWins = 0;
            let playerLosses = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;
            let maxWinStreak = 0;
            let maxLossStreak = 0;
            
            // Track patterns that would benefit players
            for (let i = 0; i < recentResults.length - 1; i++) {
                const currentNum = parseInt(recentResults[i].number);
                const nextNum = parseInt(recentResults[i + 1].number);
                
                // Simple pattern: if number alternates between odd/even
                const isPlayerWin = (currentNum % 2 === 0 && nextNum % 2 === 1) || 
                                   (currentNum % 2 === 1 && nextNum % 2 === 0);
                
                if (isPlayerWin) {
                    playerWins++;
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > maxWinStreak) maxWinStreak = currentWinStreak;
                } else {
                    playerLosses++;
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > maxLossStreak) maxLossStreak = currentLossStreak;
                }
            }
            
            const totalGames = playerWins + playerLosses;
            const winRate = totalGames > 0 ? (playerWins / totalGames) * 100 : 50;
            
            // Determine current phase
            let phase = "neutral";
            let confidence = 0;
            
            if (winRate > 60 && maxWinStreak >= 3) {
                phase = "winning";
                confidence = Math.min(90, winRate);
                wingoWinStreak = maxWinStreak;
                wingoLossStreak = 0;
            } else if (winRate < 40 && maxLossStreak >= 3) {
                phase = "losing";
                confidence = Math.min(90, 100 - winRate);
                wingoLossStreak = maxLossStreak;
                wingoWinStreak = 0;
            } else {
                phase = "neutral";
                confidence = 50;
            }
            
            // Estimate next phase change based on pattern length
            const patternLength = detectPatternLength(recentResults);
            const nextPhaseChange = Math.max(1, Math.floor(patternLength / 2));
            
            wingoGamePhase = phase;
            wingoPhaseConfidence = confidence;
            wingoPlayerWinRate = winRate;
            wingoPhaseDuration = recentResults.length;
            wingoExpectedPhaseChange = nextPhaseChange;
            
            return {
                phase: phase,
                confidence: Math.round(confidence),
                winRate: Math.round(winRate),
                winStreak: maxWinStreak,
                lossStreak: maxLossStreak,
                nextPhaseChange: nextPhaseChange,
                description: getPhaseDescription(phase, winRate, maxWinStreak, maxLossStreak)
            };
        }
        
        // Detect pattern length in results (SAME AS FIRST FILE)
        function detectPatternLength(results) {
            if (results.length < 10) return 5;
            
            // Try to find repeating patterns
            for (let len = 3; len <= 10; len++) {
                let isPattern = true;
                for (let i = 0; i < results.length - len; i++) {
                    const num1 = parseInt(results[i].number);
                    const num2 = parseInt(results[i + len].number);
                    if (num1 !== num2) {
                        isPattern = false;
                        break;
                    }
                }
                if (isPattern) return len;
            }
            return 5; // default
        }
        
        // Get phase description (SAME AS FIRST FILE)
        function getPhaseDescription(phase, winRate, winStreak, lossStreak) {
            switch(phase) {
                case "winning":
                    return `Game is distributing wins (${Math.round(winRate)}% win rate, ${winStreak} win streak)`;
                case "losing":
                    return `Game is recovering losses (${Math.round(100 - winRate)}% loss rate, ${lossStreak} loss streak)`;
                default:
                    return `Game is balanced (${Math.round(winRate)}% win rate)`;
            }
        }
        
        // Predict next number based on current algorithm (SAME AS FIRST FILE)
        function predictNextNumber() {
            if (!currentAlgorithm) return Math.floor(Math.random() * 10);
            
            if (currentAlgorithm.name === "PATTERN_BREAKER") {
                // For pattern breaker, use weighted random
                const recentResults = resultsData.slice(0, 20);
                const numberCounts = new Array(10).fill(0);
                
                for (const item of recentResults) {
                    const num = parseInt(item.number);
                    if (num >= 0 && num <= 9) {
                        numberCounts[num]++;
                    }
                }
                
                // Find least frequent number
                let minCount = Math.min(...numberCounts);
                let leastFrequentNumbers = [];
                for (let i = 0; i < 10; i++) {
                    if (numberCounts[i] === minCount) {
                        leastFrequentNumbers.push(i);
                    }
                }
                
                return leastFrequentNumbers[Math.floor(Math.random() * leastFrequentNumbers.length)];
            } else {
                // Use pattern-based prediction
                const nextIndex = currentPatternIndex % currentAlgorithm.pattern.length;
                const nextNumber = currentAlgorithm.pattern[nextIndex];
                currentPatternIndex = (currentPatternIndex + 1) % currentAlgorithm.pattern.length;
                return nextNumber;
            }
        }
        
        // Get color from number (SAME AS FIRST FILE)
        function getColorFromNumber(number) {
            if (number === 0 || number === 5) return "VIOLET";
            return number % 2 === 0 ? "RED" : "GREEN";
        }
        
        // Get size from number (SAME AS FIRST FILE)
        function getSizeFromNumber(number) {
            return number >= 5 ? "BIG" : "SMALL";
        }
        
        // Initialize algorithm (SAME AS FIRST FILE)
        function initializeAlgorithm() {
            // Start with WIN_DISTRIBUTION algorithm
            currentAlgorithm = WINGO_ALGORITHMS.WIN_DISTRIBUTION;
            algorithmConfidence = 85;
            patternCycleLength = currentAlgorithm.pattern.length;
            currentPatternIndex = 0;
            algorithmHistory = [];
            algorithmChangeCount = 0;
            algorithmPerformance = { wins: 0, losses: 0, accuracy: 0 };
            
            // Add initial algorithm to history
            algorithmHistory.push({
                algorithm: currentAlgorithm.name,
                timestamp: Date.now(),
                confidence: algorithmConfidence,
                pattern: [...currentAlgorithm.pattern],
                description: currentAlgorithm.description
            });
        }
        
        // Detect current algorithm from recent results (SAME AS FIRST FILE)
        function detectCurrentAlgorithm() {
            if (!resultsData || resultsData.length < 15) {
                return null;
            }
            
            const recentResults = resultsData.slice(0, 30);
            const recentNumbers = recentResults.map(item => parseInt(item.number));
            const recentColors = recentResults.map(item => {
                const num = parseInt(item.number);
                return getColorFromNumber(num);
            });
            const recentSizes = recentResults.map(item => {
                const num = parseInt(item.number);
                return getSizeFromNumber(num);
            });
            
            // Check which algorithm matches best
            let bestMatch = null;
            let bestScore = 0;
            
            for (const [algoName, algorithm] of Object.entries(WINGO_ALGORITHMS)) {
                let score = 0;
                const patternLength = algorithm.pattern.length;
                
                // Check number pattern match with sliding window
                for (let offset = 0; offset < Math.min(5, recentNumbers.length - patternLength); offset++) {
                    let matchCount = 0;
                    for (let j = 0; j < patternLength && offset + j < recentNumbers.length; j++) {
                        if (recentNumbers[offset + j] === algorithm.pattern[j]) {
                            matchCount++;
                        }
                    }
                    const patternScore = (matchCount / patternLength) * 100;
                    if (patternScore > score) {
                        score = patternScore;
                    }
                }
                
                // Apply game phase weighting
                if (wingoGamePhase === "winning" && algorithm.winProbability > 0.6) {
                    score *= 1.3;
                } else if (wingoGamePhase === "losing" && algorithm.winProbability < 0.4) {
                    score *= 1.3;
                }
                
                // Apply confidence weighting
                score = score * (algorithm.confidence / 100);
                
                if (score > bestScore && score > 50) {
                    bestScore = score;
                    bestMatch = algorithm;
                }
            }
            
            // If no good match found, use game phase to decide
            if (!bestMatch) {
                if (wingoGamePhase === "winning") {
                    bestMatch = WINGO_ALGORITHMS.WIN_DISTRIBUTION;
                    bestScore = 70;
                } else if (wingoGamePhase === "losing") {
                    bestMatch = WINGO_ALGORITHMS.LOSS_RECOVERY;
                    bestScore = 70;
                } else {
                    bestMatch = WINGO_ALGORITHMS.BALANCE_MAINTENANCE;
                    bestScore = 65;
                }
            }
            
            return bestMatch ? { algorithm: bestMatch, confidence: bestScore } : null;
        }
        
        // Update algorithm based on detection (SAME AS FIRST FILE)
        function updateAlgorithm() {
            const detected = detectCurrentAlgorithm();
            const wingoAnalysis = analyzeWingoGameStrategy();
            
            if (detected && detected.confidence > 60) {
                // Check if algorithm is different from current
                if (!currentAlgorithm || detected.algorithm.name !== currentAlgorithm.name) {
                    // Change algorithm
                    const oldAlgorithm = currentAlgorithm ? currentAlgorithm.name : "NONE";
                    currentAlgorithm = detected.algorithm;
                    algorithmConfidence = detected.confidence;
                    patternCycleLength = currentAlgorithm.pattern.length;
                    currentPatternIndex = 0;
                    algorithmChangeDetected = true;
                    lastAlgorithmChange = Date.now();
                    algorithmChangeCount++;
                    
                    // Reset performance for new algorithm
                    algorithmPerformance = { wins: 0, losses: 0, accuracy: 0 };
                    
                    // Add to history
                    algorithmHistory.push({
                        algorithm: currentAlgorithm.name,
                        timestamp: Date.now(),
                        confidence: algorithmConfidence,
                        oldAlgorithm: oldAlgorithm,
                        gamePhase: wingoAnalysis.phase,
                        reason: `Auto-detected with ${Math.round(detected.confidence)}% confidence`
                    });
                    
                    return true;
                } else {
                    // Same algorithm, update confidence
                    algorithmConfidence = Math.min(95, algorithmConfidence * 0.7 + detected.confidence * 0.3);
                }
            }
            
            return false;
        }
        
        // Generate prediction based on current algorithm and game analysis (SAME AS FIRST FILE)
        function generateWingoPrediction() {
            // Get game analysis
            const wingoAnalysis = analyzeWingoGameStrategy();
            
            // Predict next number based on current algorithm
            const predictedNumber = predictNextNumber();
            const predictedColor = getColorFromNumber(predictedNumber);
            const predictedSize = getSizeFromNumber(predictedNumber);
            
            // Decide prediction type based on game phase
            let predictionType, predictionValue, predictionMode;
            
            if (wingoAnalysis.phase === "winning") {
                // In winning phase, follow the algorithm closely
                predictionType = Math.random() > 0.4 ? 'color' : 'size';
                predictionValue = predictionType === 'color' ? predictedColor : predictedSize;
                predictionMode = predictionType === 'color' ? 'COLOR' : 'SIZE';
            } else if (wingoAnalysis.phase === "losing") {
                // In losing phase, be more cautious but still predict
                predictionType = Math.random() > 0.6 ? 'color' : 'size';
                predictionValue = predictionType === 'color' ? predictedColor : predictedSize;
                predictionMode = predictionType === 'color' ? 'COLOR' : 'SIZE';
            } else {
                // Neutral phase
                predictionType = Math.random() > 0.5 ? 'color' : 'size';
                predictionValue = predictionType === 'color' ? predictedColor : predictedSize;
                predictionMode = predictionType === 'color' ? 'COLOR' : 'SIZE';
            }
            
            return {
                type: predictionType,
                value: predictionValue,
                mode: predictionMode,
                number: predictedNumber,
                color: predictedColor,
                size: predictedSize,
                confidence: algorithmConfidence,
                reason: `Algorithm: ${currentAlgorithm.name} | Game Phase: ${wingoAnalysis.phase} | Confidence: ${Math.round(algorithmConfidence)}%`
            };
        }
        
        // Get opposite prediction (UPDATED - always show opposite)
        function getOppositePrediction(prediction) {
            let oppositeValue;
            
            if (prediction.type === 'color') {
                // Handle color prediction - opposite of RED is GREEN, opposite of GREEN is RED
                // For VIOLET, we'll convert to RED or GREEN randomly (as per requirement: Violet prediction won't show)
                if (prediction.value === 'RED') {
                    oppositeValue = 'GREEN';
                } else if (prediction.value === 'GREEN') {
                    oppositeValue = 'RED';
                } else { // VIOLET
                    // Convert VIOLET to either RED or GREEN randomly
                    oppositeValue = Math.random() > 0.5 ? 'RED' : 'GREEN';
                }
            } else { // size
                // Handle size prediction - opposite of BIG is SMALL, opposite of SMALL is BIG
                if (prediction.value === 'BIG') {
                    oppositeValue = 'SMALL';
                } else {
                    oppositeValue = 'BIG';
                }
            }
            
            return {
                type: prediction.type,
                value: oppositeValue,
                original: prediction.value,
                number: prediction.number,
                color: prediction.color,
                size: prediction.size,
                confidence: prediction.confidence,
                reason: `Opposite of: ${prediction.value} | ${prediction.reason}`
            };
        }
        
        // Initialize prediction page
        async function initializePredictionPage() {
            // Load coins from localStorage
            coins = parseInt(localStorage.getItem('wingo_coins')) || 0;
            document.getElementById('available-coins').textContent = coins;
            
            // Set UID display
            userUid = generateUid();
            document.getElementById('user-uid').textContent = userUid;
            
            // Save user to Firebase if not exists
            await saveUserToFirebase();
            
            // Set up Firebase listener for real-time coin updates
            setupFirebaseListener();
            
            // Fetch initial data
            await fetchData();
            
            // Start period checker
            startPeriodChecker();
            
            // Initialize algorithm (FROM FIRST FILE)
            initializeAlgorithm();
            
            // Load history
            loadHistory();
        }
        
        // Save user to Firebase
        async function saveUserToFirebase() {
            const userId = generateUserId();
            const userRef = database.ref('users/' + userId);
            
            const snapshot = await userRef.once('value');
            if (!snapshot.exists()) {
                await userRef.set({
                    uid: userUid,
                    coins: coins,
                    createdAt: Date.now(),
                    lastLogin: Date.now(),
                    platform: currentPlatform
                });
            } else {
                // Update last login
                await userRef.update({
                    lastLogin: Date.now(),
                    platform: currentPlatform
                });
                
                // Get current coins from Firebase if they exist
                const userData = snapshot.val();
                if (userData.coins !== undefined) {
                    coins = userData.coins;
                    localStorage.setItem('wingo_coins', coins);
                    document.getElementById('available-coins').textContent = coins;
                }
            }
        }
        
        // Set up Firebase listener for real-time coin updates
        function setupFirebaseListener() {
            const userId = localStorage.getItem('wingo_user_id');
            if (!userId) return;
            
            firebaseUserRef = database.ref('users/' + userId);
            
            firebaseUserRef.on('value', (snapshot) => {
                const userData = snapshot.val();
                if (userData && userData.coins !== undefined) {
                    // Update local coins
                    coins = userData.coins;
                    localStorage.setItem('wingo_coins', coins);
                    
                    // Update UI
                    document.getElementById('available-coins').textContent = coins;
                    
                    console.log('Coins updated from Firebase:', coins);
                }
            });
        }
        
        // Update coins in Firebase
        async function updateCoinsInFirebase(newCoins) {
            const userId = localStorage.getItem('wingo_user_id');
            if (userId) {
                const userRef = database.ref('users/' + userId);
                await userRef.update({
                    coins: newCoins,
                    lastUpdate: Date.now()
                });
                console.log('Coins updated in Firebase:', newCoins);
            }
        }
        
        // Fetch data from API
        async function fetchData() {
            try {
                const response = await fetch(API_URL);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.code === 0 && data.data && data.data.list) {
                    resultsData = data.data.list;
                    return true;
                } else {
                    throw new Error('Invalid data format from API');
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                return false;
            }
        }
        
        // Start period checker
        function startPeriodChecker() {
            updatePeriod();
            setInterval(updatePeriod, 3000); // Check every 3 seconds
        }
        
        // Update period display
        async function updatePeriod() {
            await fetchData();
            
            if (resultsData && resultsData.length > 0) {
                const latestItem = resultsData[0];
                const newPeriodNumber = (BigInt(latestItem.issueNumber) + 1n).toString();
                
                // Update only if period changed
                if (newPeriodNumber !== currentPeriodNumber) {
                    currentPeriodNumber = newPeriodNumber;
                    document.getElementById('current-period').textContent = currentPeriodNumber;
                    
                    // Reset prediction for new period
                    lastPredictionPeriod = "";
                    
                    // Process pending results from previous period
                    processPendingResults();
                    
                    // Update timer
                    updatePeriodTimer();
                }
            }
        }
        
        // Update period timer
        function updatePeriodTimer() {
            clearInterval(currentPeriodTimer);
            
            let seconds = 60;
            
            currentPeriodTimer = setInterval(() => {
                seconds--;
                if (seconds < 0) {
                    seconds = 60;
                    updatePeriod(); // Refresh period
                }
                
                document.getElementById('period-timer').textContent = 
                    `Next update in: ${seconds}s`;
            }, 1000);
        }
        
        // Generate prediction
        async function generatePrediction() {
            // Check if user has enough coins
            if (coins < 5) {
                alert("Not enough coins! Please buy more coins.");
                return;
            }
            
            // Check if already predicted for this period
            if (lastPredictionPeriod === currentPeriodNumber) {
                alert("You can only generate one prediction per period!");
                return;
            }
            
            // Check if period is valid
            if (!currentPeriodNumber || currentPeriodNumber === "LOADING...") {
                alert("Please wait for period number to load!");
                return;
            }
            
            // Disable generate button during processing
            const generateBtn = document.getElementById('generate-btn');
            generateBtn.disabled = true;
            
            // Deduct coins
            coins -= 5;
            localStorage.setItem('wingo_coins', coins);
            document.getElementById('available-coins').textContent = coins;
            
            // Update coins in Firebase
            await updateCoinsInFirebase(coins);
            
            // Mark this period as predicted
            lastPredictionPeriod = currentPeriodNumber;
            
            // Show analysis animation
            const analysisContainer = document.getElementById('analysis-container');
            const predictionResult = document.getElementById('prediction-result');
            const progressBar = document.getElementById('progress-bar');
            
            analysisContainer.style.display = 'block';
            predictionResult.style.display = 'none';
            
            // Reset and start progress bar
            progressBar.style.width = '0%';
            setTimeout(() => {
                progressBar.style.width = '100%';
            }, 10);
            
            // Generate Unix terminal analysis
            generateUnixAnalysis();
            
            // Generate graph animation
            generateUnixGraph();
            
            // Wait 5 seconds for animation
            setTimeout(async () => {
                // Generate actual prediction (FROM FIRST FILE LOGIC)
                await fetchData();
                
                // Update algorithm detection
                updateAlgorithm();
                
                // Generate actual prediction using advanced logic
                const actualPrediction = generateWingoPrediction();
                
                // Get opposite prediction (ALWAYS SHOW OPPOSITE)
                const oppositePrediction = getOppositePrediction(actualPrediction);
                
                // Display the OPPOSITE prediction
                displayPrediction(oppositePrediction);
                
                // Save prediction to history as PENDING
                savePredictionToHistory(oppositePrediction, actualPrediction);
                
                // Hide analysis, show result
                analysisContainer.style.display = 'none';
                predictionResult.style.display = 'block';
                
                // Re-enable generate button
                generateBtn.disabled = false;
            }, 5000);
        }
        
        // Generate Unix terminal analysis
        function generateUnixAnalysis() {
            const analysisText = document.getElementById('analysis-text');
            const terminalLines = [
                "> Connecting to Wingo API... OK",
                "> Fetching last 100 results... OK",
                "> Analyzing algorithm patterns...",
                "> Detected pattern: " + (currentAlgorithm ? currentAlgorithm.name : "Scanning"),
                "> Confidence level: " + Math.round(algorithmConfidence) + "%",
                "> Calculating probability matrix...",
                "> Processing historical data...",
                "> Generating prediction model...",
                "> Encrypting final result...",
                "> Prediction ready!"
            ];
            
            let text = "";
            let index = 0;
            
            const interval = setInterval(() => {
                if (index < terminalLines.length) {
                    text += terminalLines[index] + "<br>";
                    analysisText.innerHTML = text;
                    index++;
                } else {
                    clearInterval(interval);
                }
            }, 400);
        }
        
        // Generate Unix-style graph
        function generateUnixGraph() {
            const graphCanvas = document.getElementById('graph-canvas');
            graphCanvas.innerHTML = '';
            
            // Create graph axis
            const axis = document.createElement('div');
            axis.className = 'graph-line';
            graphCanvas.appendChild(axis);
            
            // Create animated points for trend
            const pointCount = 12;
            const points = [];
            let lastY = 50;
            
            for (let i = 0; i < pointCount; i++) {
                const point = document.createElement('div');
                point.className = 'graph-point';
                
                const x = (i / (pointCount - 1)) * 100;
                
                // Create trending pattern
                let y;
                if (i === 0) {
                    y = 50;
                } else {
                    // Random but trending upward/downward
                    const trend = Math.random() > 0.5 ? 1 : -1;
                    const change = Math.random() * 20 + 10;
                    y = Math.max(10, Math.min(90, lastY + (change * trend)));
                }
                lastY = y;
                
                point.style.left = `${x}%`;
                point.style.bottom = `${y}%`;
                
                // Animate point with delay
                point.style.animation = `pointPulse ${Math.random() * 0.5 + 0.5}s infinite alternate`;
                point.style.animationDelay = `${i * 0.2}s`;
                
                graphCanvas.appendChild(point);
                points.push(point);
                
                // Connect points with lines
                if (i > 0) {
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.height = '1px';
                    line.style.background = 'var(--matrix-green)';
                    line.style.boxShadow = '0 0 5px var(--matrix-green)';
                    
                    const prevX = ((i-1) / (pointCount - 1)) * 100;
                    const prevY = points[i-1].style.bottom;
                    
                    const x1 = `calc(${prevX}% + 3px)`;
                    const y1 = prevY;
                    const x2 = `calc(${x}% - 3px)`;
                    const y2 = `${y}%`;
                    
                    const distance = Math.sqrt(Math.pow(parseFloat(x) - parseFloat(prevX), 2) + Math.pow(y - parseFloat(prevY.replace('%', '')), 2));
                    const angle = Math.atan2(y - parseFloat(prevY.replace('%', '')), parseFloat(x) - parseFloat(prevX)) * 180 / Math.PI;
                    
                    line.style.width = `${distance}%`;
                    line.style.left = x1;
                    line.style.bottom = y1;
                    line.style.transformOrigin = '0 0';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.opacity = '0.7';
                    
                    graphCanvas.appendChild(line);
                }
            }
            
            // Add CSS for point animation if not exists
            if (!document.querySelector('#graphAnimations')) {
                const style = document.createElement('style');
                style.id = 'graphAnimations';
                style.textContent = `
                    @keyframes pointPulse {
                        0% { transform: translate(-50%, 50%) scale(1); opacity: 0.7; }
                        100% { transform: translate(-50%, 50%) scale(1.5); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Display prediction
        function displayPrediction(prediction) {
            const predictionValue = document.getElementById('prediction-value');
            const predictionType = document.getElementById('prediction-type');
            
            predictionValue.textContent = prediction.value;
            predictionType.textContent = prediction.type.toUpperCase() + " PREDICTION";
            
            // Set color based on prediction value
            predictionValue.className = 'prediction-value';
            
            if (prediction.type === 'color') {
                if (prediction.value === 'RED') {
                    predictionValue.classList.add('prediction-red');
                } else if (prediction.value === 'GREEN') {
                    predictionValue.classList.add('prediction-green');
                } else {
                    // VIOLET won't be shown, but just in case
                    predictionValue.classList.add('prediction-violet');
                }
            } else {
                if (prediction.value === 'BIG') {
                    predictionValue.classList.add('prediction-big');
                } else {
                    predictionValue.classList.add('prediction-small');
                }
            }
        }
        
        // Save prediction to history
        function savePredictionToHistory(oppositePrediction, actualPrediction) {
            const historyItem = {
                period: currentPeriodNumber,
                prediction: oppositePrediction.value,
                type: oppositePrediction.type,
                originalPrediction: actualPrediction.value,
                timestamp: Date.now(),
                status: 'PENDING',
                algorithm: currentAlgorithm ? currentAlgorithm.name : 'UNKNOWN',
                confidence: Math.round(algorithmConfidence)
            };
            
            // Check if prediction already exists for this period
            const existingIndex = historyData.findIndex(item => item.period === currentPeriodNumber);
            if (existingIndex !== -1) {
                historyData[existingIndex] = historyItem;
            } else {
                historyData.unshift(historyItem);
            }
            
            // Keep only last 20 predictions
            if (historyData.length > 20) {
                historyData = historyData.slice(0, 20);
            }
            
            localStorage.setItem('wingo_history', JSON.stringify(historyData));
            
            // Update history display
            updateHistoryDisplay();
        }
        
        // Process pending results
        function processPendingResults() {
            if (historyData.length === 0) return;
            
            // Get previous period
            const previousPeriod = (BigInt(currentPeriodNumber) - 1n).toString();
            
            // Find pending prediction for previous period
            const pendingItem = historyData.find(item => 
                item.status === 'PENDING' && item.period === previousPeriod
            );
            
            if (!pendingItem) return;
            
            // Find the actual result for this period
            const actualResult = resultsData.find(item => item.issueNumber === previousPeriod);
            
            if (actualResult) {
                const actualNum = parseInt(actualResult.number);
                const actualColor = getColorFromNumber(actualNum);
                const actualSize = getSizeFromNumber(actualNum);
                
                // Determine if prediction was correct
                let isWin = false;
                
                if (pendingItem.type === 'color') {
                    isWin = (pendingItem.prediction === actualColor);
                } else { // size
                    isWin = (pendingItem.prediction === actualSize);
                }
                
                // Update history item
                pendingItem.status = isWin ? 'WIN' : 'LOSS';
                pendingItem.actualResult = `${actualNum} (${actualSize}/${actualColor})`;
                pendingItem.processedAt = Date.now();
                pendingItem.wasCorrect = (pendingItem.originalPrediction === (pendingItem.type === 'color' ? actualColor : actualSize));
                
                // Update stats
                totalPredictions++;
                if (isWin) correctPredictions++;
                
                // Update streaks
                if (isWin) {
                    winStreak++;
                    lossStreak = 0;
                } else {
                    lossStreak++;
                    winStreak = 0;
                }
                
                // Save updated history
                localStorage.setItem('wingo_history', JSON.stringify(historyData));
                
                // Update history display
                updateHistoryDisplay();
            }
        }
        
        // Load history from localStorage
        function loadHistory() {
            const savedHistory = localStorage.getItem('wingo_history');
            if (savedHistory) {
                historyData = JSON.parse(savedHistory);
                updateHistoryDisplay();
            }
        }
        
        // Update history display
        function updateHistoryDisplay() {
            const historyItems = document.getElementById('history-items');
            historyItems.innerHTML = '';
            
            if (historyData.length === 0) {
                historyItems.innerHTML = '<div class="no-prediction">No predictions yet. Generate your first prediction!</div>';
                return;
            }
            
            // Show last 10 history items
            const recentHistory = historyData.slice(0, 10);
            
            recentHistory.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                const resultClass = item.status === 'WIN' ? 'win' : 
                                  item.status === 'LOSS' ? 'loss' : 'pending';
                
                const resultText = item.status === 'PENDING' ? 'Pending' : 
                                 item.status === 'WIN' ? 'WIN' : 'LOSS';
                
                // Shorten period number for display
                const shortPeriod = item.period.length > 10 ? 
                    item.period.substring(item.period.length - 8) : item.period;
                
                historyItem.innerHTML = `
                    <div class="history-period">Period ${shortPeriod}</div>
                    <div class="history-prediction">${item.prediction}</div>
                    <div class="history-result ${resultClass}">${resultText}</div>
                `;
                
                historyItems.appendChild(historyItem);
            });
        }
        
        // Initialize on page load
        window.onload = function() {
            userId = generateUserId();
            userUid = generateUid();
            initializeEffects();
            
            // Check if user has already scratched before
            hasScratchedBefore = localStorage.getItem('wingo_has_scratched') === 'true';
            
            // If user has coins and has scratched before, go directly to prediction page
            const savedCoins = localStorage.getItem('wingo_coins');
            if (savedCoins && parseInt(savedCoins) > 0 && hasScratchedBefore) {
                coins = parseInt(savedCoins);
                // Don't go directly to prediction page - user must select platform first
                // Show landing page to select platform
                document.getElementById('landing-page').style.display = 'flex';
            } else {
                // Show landing page to select platform
                document.getElementById('landing-page').style.display = 'flex';
            }
        };
        
        // Regenerate matrix columns on resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                document.getElementById('matrix-bg').innerHTML = '';
                createMatrixRain();
            }, 250);
        });
    </script>
</body>
</html>