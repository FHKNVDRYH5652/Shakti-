<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mickey X Web - Smart Wingo Predictor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>
    
    <style>
        :root {
            --neon-purple: #bc13fe;
            --neon-glow: #d670ff;
            --hacker-green: #00ff41;
            --matrix-green: #0aff0a;
            --dark-bg: #0a0a0a;
            --terminal-bg: #001100;
            --card-bg: rgba(0, 40, 0, 0.7);
            --green: #00ff00;
            --red: #ff0000;
            --gold: #ffcc00;
            --orange: #ff9900;
            --violet: #9d00ff;
            --teal: #00ffcc;
            --pink: #ff00aa;
            --yellow: #ffff00;
            --cyan: #00ffff;
            --button-blue: #0066ff;
            --button-glow: #00aaff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Rajdhani', sans-serif; user-select: none; }
        body { 
            background: linear-gradient(45deg, #000000, #001100, #000a00, #000000);
            color: white; 
            overflow-x: hidden; 
            min-height: 100vh;
            position: relative;
        }
        
        /* Matrix Code Rain Background */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: #000;
            overflow: hidden;
        }
        
        .matrix-column {
            position: absolute;
            top: -100px;
            color: var(--hacker-green);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 5px var(--hacker-green), 0 0 10px var(--hacker-green);
            white-space: nowrap;
            animation: matrixFall linear infinite;
        }
        
        @keyframes matrixFall {
            0% {
                transform: translateY(-100%);
                opacity: 0;
            }
            5% {
                opacity: 1;
            }
            95% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
        
        /* Binary Particles */
        #binary-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        
        .binary-particle {
            position: absolute;
            color: var(--matrix-green);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            opacity: 0;
            animation: binaryFloat linear infinite;
            text-shadow: 0 0 8px var(--matrix-green);
        }
        
        @keyframes binaryFloat {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) translateX(20px);
                opacity: 0;
            }
        }
        
        /* Terminal Scan Line */
        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, 
                transparent, 
                var(--hacker-green), 
                var(--matrix-green), 
                var(--hacker-green), 
                transparent);
            box-shadow: 0 0 15px var(--hacker-green);
            animation: scanMove 4s linear infinite;
            z-index: 9999;
            pointer-events: none;
            opacity: 0.7;
        }
        
        @keyframes scanMove {
            0% {
                top: 0%;
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
            100% {
                top: 100%;
                opacity: 0.7;
            }
        }
        
        /* Landing Page */
        #landing-page { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            min-height: 100vh; 
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .main-title { 
            font-family: 'Orbitron', sans-serif; 
            font-size: 3rem; 
            color: var(--hacker-green); 
            text-shadow: 0 0 20px var(--hacker-green), 0 0 40px var(--hacker-green);
            margin-bottom: 40px; 
            text-align: center;
            padding: 20px;
            border: 2px solid var(--hacker-green);
            background: rgba(0, 30, 0, 0.3);
            backdrop-filter: blur(5px);
            animation: titleGlow 3s infinite alternate;
            position: relative;
            overflow: hidden;
        }
        
        @keyframes titleGlow {
            0% {
                box-shadow: 0 0 10px var(--hacker-green),
                            inset 0 0 10px rgba(0, 255, 65, 0.2);
                text-shadow: 0 0 10px var(--hacker-green);
            }
            100% {
                box-shadow: 0 0 30px var(--hacker-green),
                            inset 0 0 20px rgba(0, 255, 65, 0.4);
                text-shadow: 0 0 20px var(--hacker-green),
                             0 0 30px var(--hacker-green);
            }
        }
        
        .platform-scroller { 
            display: flex; 
            overflow-x: auto; 
            gap: 25px; 
            width: 100%; 
            max-width: 1300px; 
            padding: 40px 20px; 
            scroll-behavior: smooth; 
            scrollbar-width: none; 
        }
        
        .platform-scroller::-webkit-scrollbar { display: none; }
        
        .platform-card { 
            flex: 0 0 280px; 
            height: 450px; 
            background: linear-gradient(135deg, 
                rgba(0, 40, 0, 0.8), 
                rgba(0, 60, 0, 0.5), 
                rgba(0, 40, 0, 0.8)); 
            border: 2px solid var(--hacker-green); 
            border-radius: 20px; 
            position: relative; 
            overflow: hidden; 
            transition: all 0.4s ease; 
            cursor: pointer; 
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .platform-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
        }
        
        .platform-card:hover { 
            transform: scale(1.08) translateY(-15px); 
            box-shadow: 0 0 40px var(--hacker-green),
                        inset 0 0 20px rgba(0, 255, 65, 0.2);
            border-color: var(--matrix-green);
            animation: cardPulse 2s infinite;
        }
        
        @keyframes cardPulse {
            0% {
                box-shadow: 0 0 20px var(--hacker-green),
                            inset 0 0 15px rgba(0, 255, 65, 0.2);
            }
            50% {
                box-shadow: 0 0 40px var(--hacker-green),
                            inset 0 0 25px rgba(0, 255, 65, 0.3);
            }
            100% {
                box-shadow: 0 0 20px var(--hacker-green),
                            inset 0 0 15px rgba(0, 255, 65, 0.2);
            }
        }
        
        .platform-label { 
            position: absolute; 
            bottom: 0; 
            width: 100%; 
            background: linear-gradient(to top, 
                rgba(0, 30, 0, 0.95), 
                rgba(0, 50, 0, 0.7)); 
            color: var(--hacker-green); 
            text-align: center; 
            padding: 20px; 
            font-weight: bold; 
            font-size: 1.4rem; 
            border-top: 2px solid var(--hacker-green);
            text-shadow: 0 0 10px var(--hacker-green);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            z-index: 2;
        }
        
        /* Platform Description */
        .platform-desc {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 0.9rem;
            color: #fff;
        }
        
        /* Scratch Cards Page */
        #scratch-page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .scratch-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: var(--hacker-green);
            text-shadow: 0 0 15px var(--hacker-green);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .scratch-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            max-width: 800px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 768px) {
            .scratch-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .scratch-card {
            width: 180px;
            height: 240px;
            background: linear-gradient(135deg, rgba(0, 50, 0, 0.8), rgba(0, 80, 0, 0.8));
            border: 3px solid var(--hacker-green);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        
        .scratch-cover {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #666, #333);
            background-size: 400% 400%;
            animation: scratchCover 3s ease-in-out infinite;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        @keyframes scratchCover {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .scratch-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.9), rgba(0, 150, 0, 0.9));
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .scratch-content.revealed {
            opacity: 1;
        }
        
        .coin-icon {
            font-size: 3rem;
            color: var(--gold);
            margin-bottom: 15px;
        }
        
        .coin-amount {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--gold);
            text-shadow: 0 0 10px var(--gold);
        }
        
        .coin-text {
            font-size: 1.2rem;
            color: white;
            margin-top: 10px;
        }
        
        .scratch-instruction {
            color: var(--hacker-green);
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1rem;
        }
        
        .coins-total {
            font-size: 1.8rem;
            color: var(--gold);
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 0 0 10px var(--gold);
        }
        
        .start-prediction-btn {
            background: linear-gradient(45deg, var(--hacker-green), var(--matrix-green));
            color: black;
            border: none;
            padding: 20px 50px;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
            display: none;
            box-shadow: 0 0 20px var(--hacker-green);
        }
        
        .start-prediction-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--hacker-green);
        }
        
        /* Video Pages */
        .video-page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background: black;
        }
        
        .video-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        .intro-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .skip-video-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            color: var(--hacker-green);
            border: 2px solid var(--hacker-green);
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s;
            z-index: 10001;
        }
        
        .skip-video-btn:hover {
            background: rgba(0, 255, 65, 0.2);
            box-shadow: 0 0 15px var(--hacker-green);
        }
        
        /* Win Streak Popup Videos - FIXED */
        .win-popup-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10002;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        .win-popup-content {
            width: 80%;
            max-width: 800px;
            height: 80%;
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.5);
            border: 3px solid var(--hacker-green);
        }
        
        .win-popup-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .win-popup-audio {
            display: none;
        }
        
        .close-popup-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,0,0,0.8);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 2rem;
            cursor: pointer;
            z-index: 10003;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
        }
        
        .close-popup-btn:hover {
            background: rgba(255,0,0,1);
            transform: scale(1.1);
        }
        
        .popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        .popup-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: var(--gold);
            text-shadow: 0 0 20px var(--gold);
            margin-bottom: 30px;
            text-align: center;
            animation: popupGlow 1.5s infinite alternate;
        }
        
        @keyframes popupGlow {
            0% {
                transform: scale(1);
                text-shadow: 0 0 10px var(--gold);
            }
            100% {
                transform: scale(1.1);
                text-shadow: 0 0 30px var(--gold);
            }
        }
        
        /* Prediction Page */
        #prediction-page {
            display: none;
            flex-direction: column;
            min-height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 30, 0, 0.5);
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid var(--hacker-green);
        }
        
        .buy-coins-btn {
            background: linear-gradient(45deg, var(--button-blue), var(--button-glow));
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.5);
        }
        
        .buy-coins-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0, 170, 255, 0.7);
        }
        
        .coins-display {
            font-size: 1.5rem;
            color: var(--gold);
            font-weight: bold;
            text-shadow: 0 0 10px var(--gold);
        }
        
        .uid-display {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 30, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid var(--hacker-green);
        }
        
        .uid-text {
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            color: var(--hacker-green);
        }
        
        .copy-uid-btn {
            background: transparent;
            border: 1px solid var(--hacker-green);
            color: var(--hacker-green);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .copy-uid-btn:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        
        .main-container {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }
        
        .game-title {
            text-align: center;
            color: var(--hacker-green);
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 0 15px var(--hacker-green);
        }
        
        .game-subtitle {
            text-align: center;
            color: #aaa;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }
        
        .period-display {
            background: rgba(0, 40, 0, 0.7);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .period-label {
            color: var(--hacker-green);
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .period-number {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--matrix-green);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px var(--matrix-green);
            word-break: break-all;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid var(--hacker-green);
            max-width: 100%;
            overflow-wrap: break-word;
        }
        
        .period-timer {
            font-size: 0.9rem;
            color: var(--orange);
            margin-top: 8px;
        }
        
        .prediction-container {
            background: rgba(0, 30, 0, 0.5);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .prediction-cost {
            color: var(--hacker-green);
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        .cost-amount {
            color: var(--gold);
            font-weight: bold;
        }
        
        .generate-btn {
            background: linear-gradient(45deg, #ff6600, #ff3300);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 10px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            width: 100%;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .generate-btn:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 30px rgba(255, 51, 0, 0.7);
        }
        
        .generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .generate-btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .generate-btn:hover::before {
            left: 100%;
        }
        
        /* Unix Terminal Analysis Animation */
        .analysis-container {
            display: none;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            height: 300px;
            overflow: hidden;
            position: relative;
            font-family: 'Courier New', monospace;
        }
        
        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: var(--hacker-green);
            border-bottom: 1px solid var(--hacker-green);
            padding-bottom: 8px;
        }
        
        .terminal-title {
            font-size: 1rem;
            font-weight: bold;
        }
        
        .terminal-controls {
            display: flex;
            gap: 10px;
        }
        
        .terminal-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .control-close { background: #ff5f56; }
        .control-minimize { background: #ffbd2e; }
        .control-maximize { background: #27ca3f; }
        
        .terminal-body {
            height: calc(100% - 60px);
            overflow: hidden;
            position: relative;
        }
        
        .terminal-output {
            color: var(--hacker-green);
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
            text-shadow: 0 0 5px var(--hacker-green);
            height: 100%;
            overflow-y: auto;
        }
        
        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: var(--hacker-green);
            animation: blink 1s infinite;
            margin-left: 2px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .graph-container {
            margin-top: 15px;
            height: 120px;
            background: rgba(0, 20, 0, 0.5);
            border: 1px solid var(--hacker-green);
            border-radius: 5px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
        }
        
        .graph-axis {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 1px;
            background: rgba(0, 255, 65, 0.5);
        }
        
        .graph-line {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(100% - 20px);
            height: 1px;
            background: var(--matrix-green);
            box-shadow: 0 0 10px var(--matrix-green);
        }
        
        .graph-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--hacker-green);
            border-radius: 50%;
            transform: translate(-50%, 50%);
            box-shadow: 0 0 8px var(--hacker-green);
        }
        
        .analysis-progress {
            position: absolute;
            bottom: 10px;
            left: 20px;
            right: 20px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--hacker-green), var(--matrix-green));
            width: 0%;
            transition: width 5s linear;
            box-shadow: 0 0 10px var(--hacker-green);
        }
        
        /* Prediction Result */
        .prediction-result {
            display: none;
            background: linear-gradient(135deg, rgba(0, 60, 0, 0.9), rgba(0, 100, 0, 0.9));
            border: 3px solid var(--hacker-green);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
        }
        
        .prediction-label {
            color: var(--hacker-green);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .prediction-value {
            font-size: 3.5rem;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            margin: 15px 0;
            text-transform: uppercase;
        }
        
        .prediction-red {
            color: #ff3333;
            text-shadow: 0 0 20px #ff3333;
        }
        
        .prediction-green {
            color: #33ff33;
            text-shadow: 0 0 20px #33ff33;
        }
        
        .prediction-violet {
            color: #cc33ff;
            text-shadow: 0 0 20px #cc33ff;
        }
        
        .prediction-big {
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00;
        }
        
        .prediction-small {
            color: #00ccff;
            text-shadow: 0 0 20px #00ccff;
        }
        
        .prediction-type {
            color: var(--matrix-green);
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .prediction-note {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 15px;
            font-style: italic;
        }
        
        /* Pattern Info Display */
        .pattern-info {
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid var(--hacker-green);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .pattern-name {
            color: var(--cyan);
            font-weight: bold;
        }
        
        .pattern-confidence {
            color: var(--gold);
            margin-left: 10px;
        }
        
        .pattern-desc {
            color: #aaa;
            margin-top: 5px;
        }
        
        /* History Panel */
        .history-panel {
            background: rgba(0, 30, 0, 0.5);
            border: 2px solid var(--hacker-green);
            border-radius: 15px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .history-title {
            color: var(--hacker-green);
            text-align: center;
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid var(--hacker-green);
        }
        
        .history-period {
            font-size: 0.9rem;
            color: #aaa;
            font-family: 'Courier New', monospace;
        }
        
        .history-prediction {
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .history-result {
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            min-width: 80px;
            text-align: center;
        }
        
        .pending {
            background: rgba(255, 255, 0, 0.2);
            color: #ffff00;
            border: 1px solid #ffff00;
        }
        
        .win {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        
        .loss {
            background: rgba(255, 0, 0, 0.2);
            color: #ff0000;
            border: 1px solid #ff0000;
        }
        
        .no-prediction {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
        
        /* Hacker Terminal Text */
        .hacker-text {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--hacker-green);
            text-shadow: 0 0 5px var(--hacker-green);
            opacity: 0.7;
            z-index: 1;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-title {
                font-size: 2rem;
            }
            
            .platform-card {
                flex: 0 0 220px;
                height: 350px;
            }
            
            .scratch-title {
                font-size: 2rem;
            }
            
            .scratch-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
            
            .scratch-card {
                width: 150px;
                height: 200px;
            }
            
            .prediction-value {
                font-size: 2.8rem;
            }
            
            .period-number {
                font-size: 1.1rem;
            }
            
            .history-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .history-result {
                align-self: flex-end;
            }
            
            .prediction-header {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .uid-display {
                justify-content: center;
            }
            
            .win-popup-content {
                width: 95%;
                height: 60%;
            }
            
            .popup-text {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>

    <!-- Matrix Code Rain Background -->
    <div id="matrix-bg"></div>
    
    <!-- Binary Particles -->
    <div id="binary-particles"></div>
    
    <!-- Terminal Scan Line -->
    <div class="scan-line"></div>
    
    <!-- Hacker Terminal Text -->
    <div class="hacker-text" id="terminal-text">
        > SYSTEM: ONLINE<br>
        > ACCESS: GRANTED<br>
        > TIME: <span id="hacker-time">00:00:00</span>
    </div>

    <!-- Win Streak Popup Container - FIXED -->
    <div class="win-popup-container" id="win-popup">
        <div class="popup-overlay">
            <div class="popup-text" id="popup-text">WIN STREAK!</div>
        </div>
        <div class="win-popup-content">
            <video class="win-popup-video" id="win-popup-video" playsinline muted></video>
            <audio class="win-popup-audio" id="win-popup-audio"></audio>
        </div>
        <button class="close-popup-btn" onclick="closeWinPopup()">Ã—</button>
    </div>

    <!-- Landing Page -->
    <section id="landing-page">
        <h1 class="main-title">CHOOSE PLATFORM</h1>
        <div class="platform-scroller">
            <div class="platform-card" onclick="selectPlatform('TASHAN')">
                <div class="platform-desc">REAL MONEY CASINO<br>FREE CHIPS DAILY</div>
                <img src="tashan.png" alt="TASHAN" onerror="this.src='https://images.unsplash.com/photo-1561043845-2f5e09749871?w=400&h=500&fit=crop'">
                <div class="platform-label">TASHAN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('DM WIN')">
                <div class="platform-desc">FAST WITHDRAWALS<br>SAFE & SECURE</div>
                <img src="dmwin.png" alt="DM WIN" onerror="this.src='https://images.unsplash.com/photo-1518998053901-5348d3961a04?w=400&h=500&fit=crop'">
                <div class="platform-label">DM WIN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('DAMAN')">
                <div class="platform-desc">HIGH LIMITS<br>BONUS REWARDS</div>
                <img src="daman.png" alt="DAMAN" onerror="this.src='https://images.unsplash.com/photo-1633265486064-086b219458ec?w=400&h=500&fit=crop'">
                <div class="platform-label">DAMAN</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('JALWA')">
                <div class="platform-desc">LIVE GAMES<br>24/7 SUPPORT</div>
                <img src="jalwa.png" alt="JALWA" onerror="this.src='https://images.unsplash.com/photo-1533105079780-92b9be482077?w=400&h=500&fit=crop'">
                <div class="platform-label">JALWA</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('82 LOTTERY')">
                <div class="platform-desc">LOTTERY GAMES<br>BIG JACKPOTS</div>
                <img src="82lottery.png" alt="82 LOTTERY" onerror="this.src='https://images.unsplash.com/photo-1589594225352-7689b5d92b3c?w=400&h=500&fit=crop'">
                <div class="platform-label">82 LOTTERY</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('BDG GAME')">
                <div class="platform-desc">CASINO GAMES<br>MULTIPLAYER</div>
                <img src="bdggame.png" alt="BDG GAME" onerror="this.src='https://images.unsplash.com/photo-1614732414444-096e5f1122d5?w=400&h=500&fit=crop'">
                <div class="platform-label">BDG GAME</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('GOA GAME')">
                <div class="platform-desc">BEACH THEME<br>SPECIAL BONUSES</div>
                <img src="goagame.png" alt="GOA GAME" onerror="this.src='https://images.unsplash.com/photo-1513814486256-9cbb0b5b73c3?w=400&h=500&fit=crop'">
                <div class="platform-label">GOA GAME</div>
            </div>
            <div class="platform-card" onclick="selectPlatform('91 CLUB')">
                <div class="platform-desc">VIP LOUNGE<br>EXCLUSIVE REWARDS</div>
                <img src="91club.png" alt="91 CLUB" onerror="this.src='https://images.unsplash.com/photo-1536922246289-88c42f957773?w=400&h=500&fit=crop'">
                <div class="platform-label">91 CLUB</div>
            </div>
        </div>
    </section>

    <!-- Scratch Cards Page -->
    <section id="scratch-page">
        <h2 class="scratch-title">SCRATCH & WIN COINS</h2>
        <p class="scratch-instruction">Scratch all 5 cards to reveal your coins bonus!</p>
        
        <div class="coins-total">Total Coins: <span id="total-coins">0</span></div>
        
        <div class="scratch-grid">
            <!-- 5 Scratch Cards -->
            <div class="scratch-card" onclick="scratchCard(0)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-0">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-0">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(1)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-1">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-1">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(2)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-2">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-2">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(3)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-3">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-3">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
            
            <div class="scratch-card" onclick="scratchCard(4)">
                <div class="scratch-cover">SCRATCH ME</div>
                <div class="scratch-content" id="card-4">
                    <div class="coin-icon">ðŸª™</div>
                    <div class="coin-amount" id="coin-4">0</div>
                    <div class="coin-text">COINS</div>
                </div>
            </div>
        </div>
        
        <button class="start-prediction-btn" onclick="startFirstVideo()">CLICK TO START PREDICTION</button>
    </section>

    <!-- First Video Page (shakti.mp4 - Skippable) -->
    <section id="first-video-page" class="video-page">
        <div class="video-container">
            <video id="first-video" class="intro-video" playsinline>
                <source src="shakti.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <button class="skip-video-btn" onclick="skipFirstVideo()">
                <i class="fas fa-forward"></i> SKIP VIDEO
            </button>
        </div>
    </section>

    <!-- Second Video Page (ready.mp4 - Not Skippable) -->
    <section id="second-video-page" class="video-page">
        <div class="video-container">
            <video id="second-video" class="intro-video" playsinline>
                <source src="ready.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <!-- No skip button for second video -->
        </div>
    </section>

    <!-- Prediction Page -->
    <section id="prediction-page">
        <div class="prediction-header">
            <button class="buy-coins-btn" onclick="buyCoins()">
                <i class="fas fa-coins"></i> BUY COINS
            </button>
            <div class="coins-display">
                <i class="fas fa-coins"></i> <span id="available-coins">0</span> COINS
            </div>
            <div class="uid-display">
                <div class="uid-text">UID: <span id="user-uid">0000000</span></div>
                <button class="copy-uid-btn" onclick="copyUid()">
                    <i class="fas fa-copy"></i> Copy
                </button>
            </div>
        </div>
        
        <div class="main-container">
            <h2 class="game-title">WINGO 1 MIN GAME PREDICTION</h2>
            <p class="game-subtitle">Smart Pattern Detection System</p>
            
            <!-- Current Pattern Info -->
            <div class="pattern-info" id="pattern-info">
                <div>Current Pattern: <span class="pattern-name" id="current-pattern">SCANNING...</span>
                <span class="pattern-confidence" id="pattern-confidence">0%</span></div>
                <div class="pattern-desc" id="pattern-desc">Analyzing recent results...</div>
            </div>
            
            <div class="period-display">
                <div class="period-label">LIVE NEXT PERIOD NUMBER</div>
                <div class="period-number" id="current-period">LOADING...</div>
                <div class="period-timer" id="period-timer"></div>
            </div>
            
            <div class="prediction-container">
                <div class="prediction-cost">
                    Prediction Cost: <span class="cost-amount">5 COINS</span> per prediction
                </div>
                
                <button class="generate-btn" id="generate-btn" onclick="generatePrediction()">
                    <i class="fas fa-bolt"></i> GENERATE PREDICTION
                </button>
                
                <!-- Unix Terminal Analysis Animation -->
                <div class="analysis-container" id="analysis-container">
                    <div class="terminal-header">
                        <div class="terminal-title">PATTERN_DETECTOR.exe</div>
                        <div class="terminal-controls">
                            <div class="terminal-control control-close"></div>
                            <div class="terminal-control control-minimize"></div>
                            <div class="terminal-control control-maximize"></div>
                        </div>
                    </div>
                    <div class="terminal-body">
                        <div class="terminal-output" id="terminal-output">
                            > Initializing pattern detector...<br>
                            > Fetching last 100 results...<br>
                            > Analyzing pattern sequences...<br>
                            <span id="analysis-text"></span>
                            <span class="terminal-cursor"></span>
                        </div>
                        <div class="graph-container">
                            <div class="graph-axis"></div>
                            <div class="graph-canvas" id="graph-canvas"></div>
                        </div>
                    </div>
                    <div class="analysis-progress">
                        <div class="progress-bar" id="progress-bar"></div>
                    </div>
                </div>
                
                <!-- Prediction Result -->
                <div class="prediction-result" id="prediction-result">
                    <div class="prediction-label">PATTERN BASED PREDICTION</div>
                    <div class="prediction-value" id="prediction-value">--</div>
                    <div class="prediction-type" id="prediction-type">--</div>
                    <div class="prediction-note">Based on detected pattern analysis</div>
                </div>
            </div>
            
            <!-- History Panel -->
            <div class="history-panel">
                <div class="history-title">PREDICTION HISTORY</div>
                <div id="history-items">
                    <div class="no-prediction">No predictions yet. Generate your first prediction!</div>
                </div>
            </div>
        </div>
    </section>

    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCShaI7FfDCvZ9t21RdBk7ATjk5PQUAeQI",
            authDomain: "wingo-predictor-hub.firebaseapp.com",
            databaseURL: "https://wingo-predictor-hub-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "wingo-predictor-hub",
            storageBucket: "wingo-predictor-hub.firebasestorage.app",
            messagingSenderId: "510934626240",
            appId: "1:510934626240:web:8df9c4b4a78964f15d2225",
            measurementId: "G-TTM7WXC4DW"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Global variables
        const API_URL = "https://wingolast100.vercel.app/api/results?typeId=1&apiKey=12a04165-748c-4144-9398-96bd2e0ad956&token=1a97a413-ff57-4097-a44c-4bd402ace8d5&limit=100";
        let resultsData = [];
        let currentPeriodNumber = "";
        let coins = 0;
        let scratchedCards = 0;
        let cardCoins = [0, 0, 0, 0, 0];
        let historyData = [];
        let winStreak = 0;
        let lossStreak = 0;
        let totalPredictions = 0;
        let correctPredictions = 0;
        let userId = "";
        let userUid = "";
        let lastPredictionPeriod = "";
        let currentPeriodTimer = null;
        let currentPlatform = "";
        let hasScratchedBefore = false;
        let firebaseUserRef = null;
        
        // Pattern Detection Variables
        let currentPattern = null;
        let currentMode = 'size'; // 'size' or 'color'
        let patternHistory = [];
        let patternConfidence = 0;
        let winStreakCount = 0;
        let consecutiveWins = 0;
        let lastWinTime = 0;
        
        // ==================== ADVANCED PATTERN DETECTION ====================
        
        // Define all possible patterns
        const PATTERNS = {
            // BASIC OUTCOME PATTERNS
            STRAIGHT_BIG: {
                name: "STRAIGHT BIG TREND",
                type: "size",
                sequence: ["BIG", "BIG", "BIG", "BIG"],
                prediction: "BIG",
                confidence: 75,
                description: "System collecting liquidity with consecutive Bigs",
                maxStreak: 6,
                breakSignal: "SMALL"
            },
            STRAIGHT_SMALL: {
                name: "STRAIGHT SMALL TREND",
                type: "size",
                sequence: ["SMALL", "SMALL", "SMALL", "SMALL"],
                prediction: "SMALL",
                confidence: 75,
                description: "System collecting liquidity with consecutive Smalls",
                maxStreak: 6,
                breakSignal: "BIG"
            },
            ALTERNATING_BS: {
                name: "ALTERNATING BIG-SMALL",
                type: "size",
                sequence: ["BIG", "SMALL", "BIG", "SMALL"],
                prediction: "BIG",
                confidence: 70,
                description: "Balancing pattern with regular alternation",
                nextPrediction: "SMALL"
            },
            ALTERNATING_SB: {
                name: "ALTERNATING SMALL-BIG",
                type: "size",
                sequence: ["SMALL", "BIG", "SMALL", "BIG"],
                prediction: "SMALL",
                confidence: 70,
                description: "Balancing pattern with regular alternation",
                nextPrediction: "BIG"
            },
            
            // TREND LENGTH PATTERNS
            SHORT_TREND_BIG: {
                name: "SHORT BIG TREND (2-3)",
                type: "size",
                sequence: ["BIG", "BIG"],
                prediction: "REVERSAL",
                confidence: 65,
                description: "Short trend likely to reverse",
                reversalTo: "SMALL"
            },
            SHORT_TREND_SMALL: {
                name: "SHORT SMALL TREND (2-3)",
                type: "size",
                sequence: ["SMALL", "SMALL"],
                prediction: "REVERSAL",
                confidence: 65,
                description: "Short trend likely to reverse",
                reversalTo: "BIG"
            },
            MEDIUM_TREND_BIG: {
                name: "MEDIUM BIG TREND (3-4)",
                type: "size",
                sequence: ["BIG", "BIG", "BIG"],
                prediction: "BREAK SOON",
                confidence: 80,
                description: "Medium trend, high probability of breaking",
                breakAfter: 1
            },
            MEDIUM_TREND_SMALL: {
                name: "MEDIUM SMALL TREND (3-4)",
                type: "size",
                sequence: ["SMALL", "SMALL", "SMALL"],
                prediction: "BREAK SOON",
                confidence: 80,
                description: "Medium trend, high probability of breaking",
                breakAfter: 1
            },
            
            // REVERSAL & FAKEOUT PATTERNS
            FAKE_CONTINUATION_BIG: {
                name: "FAKE BIG CONTINUATION",
                type: "size",
                sequence: ["BIG", "BIG", "BIG", "BIG", "BIG"],
                prediction: "REVERSAL",
                confidence: 85,
                description: "Fake continuation to trap players",
                reversalTo: "SMALL"
            },
            FAKE_CONTINUATION_SMALL: {
                name: "FAKE SMALL CONTINUATION",
                type: "size",
                sequence: ["SMALL", "SMALL", "SMALL", "SMALL", "SMALL"],
                prediction: "REVERSAL",
                confidence: 85,
                description: "Fake continuation to trap players",
                reversalTo: "BIG"
            },
            SUDDEN_FLIP_BIG: {
                name: "SUDDEN BIG TO SMALL FLIP",
                type: "size",
                sequence: ["BIG", "BIG", "BIG", "BIG", "SMALL"],
                prediction: "CONTINUE",
                confidence: 75,
                description: "Sudden flip after extended trend",
                continueWith: "SMALL"
            },
            SUDDEN_FLIP_SMALL: {
                name: "SUDDEN SMALL TO BIG FLIP",
                type: "size",
                sequence: ["SMALL", "SMALL", "SMALL", "SMALL", "BIG"],
                prediction: "CONTINUE",
                confidence: 75,
                description: "Sudden flip after extended trend",
                continueWith: "BIG"
            },
            
            // COLOR PATTERNS
            STRAIGHT_RED: {
                name: "STRAIGHT RED TREND",
                type: "color",
                sequence: ["RED", "RED", "RED", "RED"],
                prediction: "RED",
                confidence: 70,
                description: "Consecutive Reds, color trend",
                maxStreak: 5
            },
            STRAIGHT_GREEN: {
                name: "STRAIGHT GREEN TREND",
                type: "color",
                sequence: ["GREEN", "GREEN", "GREEN", "GREEN"],
                prediction: "GREEN",
                confidence: 70,
                description: "Consecutive Greens, color trend",
                maxStreak: 5
            },
            ALTERNATING_RG: {
                name: "ALTERNATING RED-GREEN",
                type: "color",
                sequence: ["RED", "GREEN", "RED", "GREEN"],
                prediction: "RED",
                confidence: 65,
                description: "Regular color alternation",
                nextPrediction: "GREEN"
            },
            ALTERNATING_GR: {
                name: "ALTERNATING GREEN-RED",
                type: "color",
                sequence: ["GREEN", "RED", "GREEN", "RED"],
                prediction: "GREEN",
                confidence: 65,
                description: "Regular color alternation",
                nextPrediction: "RED"
            },
            
            // NUMBER DISTRIBUTION PATTERNS
            LOW_HIGH_SHIFT: {
                name: "LOW TO HIGH SHIFT",
                type: "size",
                sequence: ["SMALL", "SMALL", "SMALL", "BIG", "BIG"],
                prediction: "BIG",
                confidence: 70,
                description: "Shift from low to high numbers"
            },
            HIGH_LOW_SHIFT: {
                name: "HIGH TO LOW SHIFT",
                type: "size",
                sequence: ["BIG", "BIG", "BIG", "SMALL", "SMALL"],
                prediction: "SMALL",
                confidence: 70,
                description: "Shift from high to low numbers"
            }
        };
        
        // Generate 7-digit UID
        function generateUid() {
            let uid = localStorage.getItem('wingo_user_uid');
            if (!uid) {
                uid = Math.floor(1000000 + Math.random() * 9000000).toString();
                localStorage.setItem('wingo_user_uid', uid);
            }
            return uid;
        }
        
        // Copy UID to clipboard
        function copyUid() {
            const uidText = document.getElementById('user-uid').textContent;
            navigator.clipboard.writeText(uidText).then(() => {
                alert('UID copied to clipboard: ' + uidText);
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }
        
        // Generate user ID for Firebase
        function generateUserId() {
            let id = localStorage.getItem('wingo_user_id');
            if (!id) {
                id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('wingo_user_id', id);
            }
            return id;
        }
        
        // Matrix Code Rain Effect
        function createMatrixRain() {
            const matrixBg = document.getElementById('matrix-bg');
            const chars = "01ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$+-*/=%\"'#&_(),.;:?!\\|{}<>[]^~";
            
            const columnCount = Math.floor(window.innerWidth / 20);
            
            for (let i = 0; i < columnCount; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = `${(i * 20) + Math.random() * 10}px`;
                
                let content = '';
                const charCount = Math.floor(Math.random() * 30) + 10;
                
                for (let j = 0; j < charCount; j++) {
                    content += chars[Math.floor(Math.random() * chars.length)];
                    if (j < charCount - 1) content += '<br>';
                }
                
                column.innerHTML = content;
                column.style.animationDuration = `${Math.random() * 10 + 10}s`;
                column.style.animationDelay = `${Math.random() * 5}s`;
                column.style.fontSize = `${Math.random() * 6 + 12}px`;
                column.style.opacity = Math.random() * 0.5 + 0.3;
                
                matrixBg.appendChild(column);
            }
        }
        
        // Binary Particles Effect
        function createBinaryParticles() {
            const container = document.getElementById('binary-particles');
            const binaryChars = ["0", "1"];
            
            const particleCount = 100;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'binary-particle';
                particle.textContent = binaryChars[Math.floor(Math.random() * binaryChars.length)];
                
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                const duration = Math.random() * 20 + 10;
                const delay = Math.random() * 15;
                particle.style.animationDuration = `${duration}s`;
                particle.style.animationDelay = `${delay}s`;
                
                particle.style.fontSize = `${Math.random() * 8 + 8}px`;
                
                container.appendChild(particle);
            }
        }
        
        // Update terminal time
        function updateTerminalTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            document.getElementById('hacker-time').textContent = timeString;
        }
        
        // Initialize effects
        function initializeEffects() {
            createMatrixRain();
            createBinaryParticles();
            updateTerminalTime();
            setInterval(updateTerminalTime, 1000);
        }
        
        // Select Platform
        function selectPlatform(platform) {
            currentPlatform = platform;
            
            // Check if user has already scratched cards before
            hasScratchedBefore = localStorage.getItem('wingo_has_scratched') === 'true';
            
            // Always show video when platform is selected
            // But check if scratch cards have been used before
            if (hasScratchedBefore) {
                // If already scratched before, go directly to video
                startFirstVideo();
            } else {
                // If not scratched before, show scratch cards
                openScratchPage();
            }
        }
        
        // Open Scratch Page
        function openScratchPage() {
            document.getElementById('landing-page').style.display = 'none';
            document.getElementById('scratch-page').style.display = 'flex';
            
            // Reset scratch cards if not already scratched
            if (scratchedCards === 0) {
                resetScratchCards();
            }
        }
        
        function resetScratchCards() {
            scratchedCards = 0;
            cardCoins = [0, 0, 0, 0, 0];
            
            // Reset UI
            for (let i = 0; i < 5; i++) {
                document.getElementById(`card-${i}`).classList.remove('revealed');
                document.getElementById(`coin-${i}`).textContent = '?';
            }
            
            document.getElementById('total-coins').textContent = '0';
            document.querySelector('.start-prediction-btn').style.display = 'none';
        }
        
        function scratchCard(index) {
            if (cardCoins[index] > 0) return; // Already scratched
            
            // Generate random coins between 10 and 50 (minimum 10, maximum 50)
            const randomCoins = Math.floor(Math.random() * 41) + 10; // 10-50
            cardCoins[index] = randomCoins;
            scratchedCards++;
            
            // Update UI
            document.getElementById(`card-${index}`).classList.add('revealed');
            document.getElementById(`coin-${index}`).textContent = randomCoins;
            
            // Update total coins
            coins = cardCoins.reduce((sum, coin) => sum + coin, 0);
            document.getElementById('total-coins').textContent = coins;
            
            // If all cards scratched, show start button
            if (scratchedCards === 5) {
                setTimeout(() => {
                    document.querySelector('.start-prediction-btn').style.display = 'block';
                }, 500);
                
                // Mark that user has scratched cards before
                localStorage.setItem('wingo_has_scratched', 'true');
            }
        }
        
        // Start First Video (shakti.mp4 - Skippable)
        function startFirstVideo() {
            // Hide appropriate pages based on whether we came from scratch page or directly
            if (hasScratchedBefore) {
                document.getElementById('landing-page').style.display = 'none';
            } else {
                document.getElementById('scratch-page').style.display = 'none';
            }
            
            // Save coins to localStorage if we got them from scratch cards
            if (!hasScratchedBefore) {
                localStorage.setItem('wingo_coins', coins);
            } else {
                // Load existing coins if already scratched before
                coins = parseInt(localStorage.getItem('wingo_coins')) || 0;
            }
            
            // Show first video page
            document.getElementById('first-video-page').style.display = 'flex';
            
            // Play first video (shakti.mp4)
            const firstVideo = document.getElementById('first-video');
            firstVideo.src = 'shakti.mp4';
            firstVideo.load();
            
            // Wait a moment then play
            setTimeout(() => {
                firstVideo.play().catch(e => {
                    console.log("First video play failed:", e);
                    // If autoplay fails, skip to second video
                    skipFirstVideo();
                });
            }, 500);
            
            // Auto proceed when video ends
            firstVideo.onended = function() {
                skipFirstVideo();
            };
            
            // Handle video errors
            firstVideo.onerror = function() {
                console.log("First video error, skipping to second video");
                skipFirstVideo();
            };
        }
        
        // Skip First Video
        function skipFirstVideo() {
            // Stop first video
            const firstVideo = document.getElementById('first-video');
            firstVideo.pause();
            firstVideo.currentTime = 0;
            
            // Hide first video page
            document.getElementById('first-video-page').style.display = 'none';
            
            // Show second video page
            startSecondVideo();
        }
        
        // Start Second Video (ready.mp4 - Not Skippable)
        function startSecondVideo() {
            // Show second video page
            document.getElementById('second-video-page').style.display = 'flex';
            
            // Play second video (ready.mp4)
            const secondVideo = document.getElementById('second-video');
            secondVideo.src = 'ready.mp4';
            secondVideo.load();
            
            // Wait a moment then play
            setTimeout(() => {
                secondVideo.play().catch(e => {
                    console.log("Second video play failed:", e);
                    // If autoplay fails, proceed to prediction page
                    skipSecondVideo();
                });
            }, 500);
            
            // Auto proceed when video ends
            secondVideo.onended = function() {
                skipSecondVideo();
            };
            
            // Handle video errors
            secondVideo.onerror = function() {
                console.log("Second video error, proceeding to prediction page");
                skipSecondVideo();
            };
        }
        
        // Skip Second Video (Automatically called when video ends)
        function skipSecondVideo() {
            // Stop second video
            const secondVideo = document.getElementById('second-video');
            secondVideo.pause();
            secondVideo.currentTime = 0;
            
            // Hide second video page
            document.getElementById('second-video-page').style.display = 'none';
            
            // Show prediction page
            document.getElementById('prediction-page').style.display = 'flex';
            
            // Initialize prediction page
            initializePredictionPage();
        }
        
        function buyCoins() {
            window.open('https://t.me/Predict456', '_blank');
        }
        
        // ==================== WIN/LOSS LOGIC FUNCTIONS ====================
        
        // Get color from number according to Wingo rules
        function getColorFromNumber(number) {
            // 0, 2, 4, 6, 8 are RED (even numbers)
            // 1, 3, 5, 7, 9 are GREEN (odd numbers)
            return number % 2 === 0 ? "RED" : "GREEN";
        }
        
        // Get size from number according to Wingo rules
        function getSizeFromNumber(number) {
            // 0-4 are SMALL
            // 5-9 are BIG
            return number >= 5 ? "BIG" : "SMALL";
        }
        
        // Check if prediction is correct
        function checkPredictionWin(prediction, type, actualNumber) {
            const actualColor = getColorFromNumber(actualNumber);
            const actualSize = getSizeFromNumber(actualNumber);
            
            if (type === 'color') {
                return prediction === actualColor;
            } else { // size
                return prediction === actualSize;
            }
        }
        
        // Detect current pattern from recent results
        function detectPattern() {
            if (!resultsData || resultsData.length < 10) {
                return {
                    pattern: null,
                    confidence: 0,
                    prediction: null,
                    type: 'size',
                    description: "Insufficient data for analysis"
                };
            }
            
            const recentResults = resultsData.slice(0, 15);
            const sizeSequence = [];
            const colorSequence = [];
            
            // Extract sequences
            for (let i = 0; i < Math.min(10, recentResults.length); i++) {
                const num = parseInt(recentResults[i].number);
                sizeSequence.push(getSizeFromNumber(num));
                colorSequence.push(getColorFromNumber(num));
            }
            
            // Check for pattern matches
            let bestMatch = null;
            let bestScore = 0;
            
            // Check each pattern
            for (const [patternName, pattern] of Object.entries(PATTERNS)) {
                let score = 0;
                const patternSeq = pattern.sequence;
                const seqToCheck = pattern.type === 'size' ? sizeSequence : colorSequence;
                
                // Check if pattern matches at the end of sequence
                if (seqToCheck.length >= patternSeq.length) {
                    const checkSlice = seqToCheck.slice(-patternSeq.length);
                    let matchCount = 0;
                    
                    for (let i = 0; i < patternSeq.length; i++) {
                        if (checkSlice[i] === patternSeq[i]) {
                            matchCount++;
                        }
                    }
                    
                    score = (matchCount / patternSeq.length) * 100;
                    
                    // Apply confidence weighting
                    score = score * (pattern.confidence / 100);
                    
                    // Check for continuation patterns
                    if (patternName.includes('STRAIGHT') && matchCount === patternSeq.length) {
                        // For straight patterns, check how long it's been going
                        let continuationCount = 0;
                        const lastValue = checkSlice[checkSlice.length - 1];
                        
                        for (let i = seqToCheck.length - 1; i >= 0; i--) {
                            if (seqToCheck[i] === lastValue) {
                                continuationCount++;
                            } else {
                                break;
                            }
                        }
                        
                        // Adjust score based on continuation length
                        if (pattern.maxStreak && continuationCount >= pattern.maxStreak) {
                            score *= 0.5; // Reduce score if max streak reached
                        } else if (continuationCount > patternSeq.length) {
                            score *= 1.2; // Increase score if pattern continues
                        }
                    }
                }
                
                if (score > bestScore && score > 50) {
                    bestScore = score;
                    bestMatch = { ...pattern, score: Math.round(score) };
                }
            }
            
            // If no good pattern found, check for simple trends
            if (!bestMatch || bestScore < 60) {
                // Check for simple size trend
                const lastSize = sizeSequence[0];
                let sizeTrendCount = 1;
                
                for (let i = 1; i < sizeSequence.length; i++) {
                    if (sizeSequence[i] === lastSize) {
                        sizeTrendCount++;
                    } else {
                        break;
                    }
                }
                
                if (sizeTrendCount >= 3) {
                    bestMatch = {
                        name: `SIMPLE ${lastSize} TREND (${sizeTrendCount})`,
                        type: 'size',
                        prediction: sizeTrendCount >= 4 ? 'REVERSAL' : lastSize,
                        confidence: Math.min(80, 60 + (sizeTrendCount * 5)),
                        description: `Simple ${lastSize} trend for ${sizeTrendCount} periods`
                    };
                    bestScore = bestMatch.confidence;
                }
                
                // Check for simple color trend
                const lastColor = colorSequence[0];
                let colorTrendCount = 1;
                
                for (let i = 1; i < colorSequence.length; i++) {
                    if (colorSequence[i] === lastColor) {
                        colorTrendCount++;
                    } else {
                        break;
                    }
                }
                
                if (colorTrendCount >= 3 && colorTrendCount > sizeTrendCount) {
                    bestMatch = {
                        name: `SIMPLE ${lastColor} TREND (${colorTrendCount})`,
                        type: 'color',
                        prediction: colorTrendCount >= 4 ? 'REVERSAL' : lastColor,
                        confidence: Math.min(75, 55 + (colorTrendCount * 5)),
                        description: `Simple ${lastColor} trend for ${colorTrendCount} periods`
                    };
                    bestScore = bestMatch.confidence;
                    
                    // Check if we should switch to color mode
                    if (colorTrendCount >= 4 && currentMode === 'size') {
                        currentMode = 'color';
                    }
                }
            }
            
            // Check if we should switch modes
            if (bestMatch) {
                const colorStrength = analyzeColorStrength(colorSequence);
                const sizeStrength = analyzeSizeStrength(sizeSequence);
                
                if (colorStrength > sizeStrength + 20 && currentMode === 'size') {
                    currentMode = 'color';
                } else if (sizeStrength > colorStrength + 20 && currentMode === 'color') {
                    currentMode = 'size';
                }
            }
            
            return bestMatch ? {
                pattern: bestMatch,
                confidence: bestScore,
                prediction: determinePrediction(bestMatch, sizeSequence, colorSequence),
                type: currentMode,
                description: bestMatch.description
            } : {
                pattern: null,
                confidence: 0,
                prediction: getRandomPrediction(),
                type: currentMode,
                description: "No clear pattern detected, using random prediction"
            };
        }
        
        // Analyze color pattern strength
        function analyzeColorStrength(colorSequence) {
            if (colorSequence.length < 5) return 0;
            
            let strength = 0;
            const lastColor = colorSequence[0];
            let trendCount = 1;
            
            for (let i = 1; i < colorSequence.length; i++) {
                if (colorSequence[i] === lastColor) {
                    trendCount++;
                } else {
                    break;
                }
            }
            
            strength = trendCount * 15;
            
            // Check for alternation pattern
            let alternationCount = 0;
            for (let i = 0; i < colorSequence.length - 1; i++) {
                if (colorSequence[i] !== colorSequence[i + 1]) {
                    alternationCount++;
                }
            }
            
            if (alternationCount >= colorSequence.length - 2) {
                strength += 30;
            }
            
            return Math.min(100, strength);
        }
        
        // Analyze size pattern strength
        function analyzeSizeStrength(sizeSequence) {
            if (sizeSequence.length < 5) return 0;
            
            let strength = 0;
            const lastSize = sizeSequence[0];
            let trendCount = 1;
            
            for (let i = 1; i < sizeSequence.length; i++) {
                if (sizeSequence[i] === lastSize) {
                    trendCount++;
                } else {
                    break;
                }
            }
            
            strength = trendCount * 15;
            
            // Check for alternation pattern
            let alternationCount = 0;
            for (let i = 0; i < sizeSequence.length - 1; i++) {
                if (sizeSequence[i] !== sizeSequence[i + 1]) {
                    alternationCount++;
                }
            }
            
            if (alternationCount >= sizeSequence.length - 2) {
                strength += 30;
            }
            
            return Math.min(100, strength);
        }
        
        // Determine prediction based on pattern
        function determinePrediction(pattern, sizeSequence, colorSequence) {
            if (!pattern) return getRandomPrediction();
            
            const lastSize = sizeSequence[0];
            const lastColor = colorSequence[0];
            
            if (pattern.prediction === 'REVERSAL') {
                if (pattern.type === 'size') {
                    return lastSize === 'BIG' ? 'SMALL' : 'BIG';
                } else {
                    return lastColor === 'RED' ? 'GREEN' : 'RED';
                }
            } else if (pattern.prediction === 'BREAK SOON') {
                // For break soon patterns, predict continuation but with lower confidence
                if (pattern.type === 'size') {
                    return lastSize;
                } else {
                    return lastColor;
                }
            } else if (pattern.nextPrediction) {
                return pattern.nextPrediction;
            } else if (pattern.reversalTo) {
                return pattern.reversalTo;
            } else if (pattern.continueWith) {
                return pattern.continueWith;
            } else {
                return pattern.prediction;
            }
        }
        
        // Get random prediction (fallback)
        function getRandomPrediction() {
            if (currentMode === 'size') {
                return Math.random() > 0.5 ? 'BIG' : 'SMALL';
            } else {
                return Math.random() > 0.5 ? 'RED' : 'GREEN';
            }
        }
        
        // Update pattern display
        function updatePatternDisplay(patternInfo) {
            if (patternInfo.pattern) {
                document.getElementById('current-pattern').textContent = patternInfo.pattern.name;
                document.getElementById('pattern-confidence').textContent = Math.round(patternInfo.confidence) + '%';
                document.getElementById('pattern-desc').textContent = patternInfo.description;
                
                // Update current pattern
                currentPattern = patternInfo.pattern;
                patternConfidence = patternInfo.confidence;
            }
        }
        
        // Play win streak popup video - FIXED VERSION
        function playWinStreakPopup() {
            console.log('Playing win streak popup for consecutive wins:', consecutiveWins);
            
            const popup = document.getElementById('win-popup');
            const video = document.getElementById('win-popup-video');
            const audio = document.getElementById('win-popup-audio');
            const popupText = document.getElementById('popup-text');
            
            if (!popup || !video || !audio) {
                console.error('Popup elements not found!');
                return;
            }
            
            let videoFile, audioFile, popupMessage;
            
            if (consecutiveWins === 1) {
                videoFile = 'win.mp4';
                audioFile = 'win.mp3';
                popupMessage = 'WIN!';
            } else if (consecutiveWins === 2) {
                videoFile = '2strike.mp4';
                audioFile = '2strike.mp3';
                popupMessage = '2 STRIKE!';
            } else if (consecutiveWins === 3) {
                videoFile = '3strike.mp4';
                audioFile = '3strike.mp3';
                popupMessage = '3 STRIKE!';
            } else {
                videoFile = 'unstoppable.mp4';
                audioFile = 'unstoppable.mp3';
                popupMessage = 'UNSTOPPABLE!';
            }
            
            // Update popup text
            popupText.textContent = popupMessage;
            
            // Set video source
            video.src = videoFile;
            audio.src = audioFile;
            
            // Show popup
            popup.style.display = 'flex';
            
            // Load and play video
            video.load();
            audio.load();
            
            // Wait for video to load, then play
            video.oncanplaythrough = function() {
                console.log('Video loaded, attempting to play...');
                
                // Play video with muted attribute to avoid autoplay restrictions
                const playPromise = video.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Video playing successfully');
                        
                        // Play audio after a short delay
                        setTimeout(() => {
                            audio.play().then(() => {
                                console.log('Audio playing successfully');
                            }).catch(e => {
                                console.log('Audio play error:', e);
                            });
                        }, 100);
                        
                    }).catch(e => {
                        console.log('Video play error:', e);
                        
                        // If video fails to play, try with user interaction
                        popup.onclick = function() {
                            video.play();
                            audio.play();
                            popup.onclick = null;
                        };
                    });
                }
            };
            
            // Handle video errors
            video.onerror = function() {
                console.log('Video error, trying alternative method');
                
                // Try direct play
                setTimeout(() => {
                    video.play().catch(e => {
                        console.log('Alternative video play failed:', e);
                    });
                }, 1000);
            };
            
            // Auto close after 3 seconds
            setTimeout(() => {
                closeWinPopup();
            }, 3000);
        }
        
        // Close win popup
        function closeWinPopup() {
            console.log('Closing win popup');
            const popup = document.getElementById('win-popup');
            const video = document.getElementById('win-popup-video');
            const audio = document.getElementById('win-popup-audio');
            
            if (video) {
                video.pause();
                video.currentTime = 0;
            }
            
            if (audio) {
                audio.pause();
                audio.currentTime = 0;
            }
            
            if (popup) {
                popup.style.display = 'none';
            }
        }
        
        // Initialize prediction page
        async function initializePredictionPage() {
            console.log('Initializing prediction page...');
            
            // Load coins from localStorage
            coins = parseInt(localStorage.getItem('wingo_coins')) || 0;
            document.getElementById('available-coins').textContent = coins;
            
            // Set UID display
            userUid = generateUid();
            document.getElementById('user-uid').textContent = userUid;
            
            // Save user to Firebase if not exists
            await saveUserToFirebase();
            
            // Set up Firebase listener for real-time coin updates
            setupFirebaseListener();
            
            // Fetch initial data
            await fetchData();
            
            // Start period checker
            startPeriodChecker();
            
            // Initialize pattern detection
            initializePatternDetection();
            
            // Load history
            loadHistory();
            
            console.log('Prediction page initialized successfully');
        }
        
        // Initialize pattern detection
        function initializePatternDetection() {
            // Initial pattern detection
            const patternInfo = detectPattern();
            updatePatternDisplay(patternInfo);
            
            // Update pattern every 10 seconds
            setInterval(() => {
                if (resultsData.length > 0) {
                    const patternInfo = detectPattern();
                    updatePatternDisplay(patternInfo);
                }
            }, 10000);
        }
        
        // Save user to Firebase
        async function saveUserToFirebase() {
            const userId = generateUserId();
            const userRef = database.ref('users/' + userId);
            
            const snapshot = await userRef.once('value');
            if (!snapshot.exists()) {
                await userRef.set({
                    uid: userUid,
                    coins: coins,
                    createdAt: Date.now(),
                    lastLogin: Date.now(),
                    platform: currentPlatform
                });
            } else {
                // Update last login
                await userRef.update({
                    lastLogin: Date.now(),
                    platform: currentPlatform
                });
                
                // Get current coins from Firebase if they exist
                const userData = snapshot.val();
                if (userData.coins !== undefined) {
                    coins = userData.coins;
                    localStorage.setItem('wingo_coins', coins);
                    document.getElementById('available-coins').textContent = coins;
                }
            }
        }
        
        // Set up Firebase listener for real-time coin updates
        function setupFirebaseListener() {
            const userId = localStorage.getItem('wingo_user_id');
            if (!userId) return;
            
            firebaseUserRef = database.ref('users/' + userId);
            
            firebaseUserRef.on('value', (snapshot) => {
                const userData = snapshot.val();
                if (userData && userData.coins !== undefined) {
                    // Update local coins
                    coins = userData.coins;
                    localStorage.setItem('wingo_coins', coins);
                    
                    // Update UI
                    document.getElementById('available-coins').textContent = coins;
                }
            });
        }
        
        // Update coins in Firebase
        async function updateCoinsInFirebase(newCoins) {
            const userId = localStorage.getItem('wingo_user_id');
            if (userId) {
                const userRef = database.ref('users/' + userId);
                await userRef.update({
                    coins: newCoins,
                    lastUpdate: Date.now()
                });
            }
        }
        
        // Fetch data from API
        async function fetchData() {
            try {
                const response = await fetch(API_URL);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.code === 0 && data.data && data.data.list) {
                    resultsData = data.data.list;
                    return true;
                } else {
                    throw new Error('Invalid data format from API');
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                return false;
            }
        }
        
        // Start period checker
        function startPeriodChecker() {
            updatePeriod();
            setInterval(updatePeriod, 3000); // Check every 3 seconds
        }
        
        // Update period display
        async function updatePeriod() {
            await fetchData();
            
            if (resultsData && resultsData.length > 0) {
                const latestItem = resultsData[0];
                const newPeriodNumber = (BigInt(latestItem.issueNumber) + 1n).toString();
                
                // Update only if period changed
                if (newPeriodNumber !== currentPeriodNumber) {
                    currentPeriodNumber = newPeriodNumber;
                    document.getElementById('current-period').textContent = currentPeriodNumber;
                    
                    // Reset prediction for new period
                    lastPredictionPeriod = "";
                    
                    // Process pending results from previous period
                    processPendingResults();
                    
                    // Update timer
                    updatePeriodTimer();
                    
                    // Update pattern detection
                    const patternInfo = detectPattern();
                    updatePatternDisplay(patternInfo);
                }
            }
        }
        
        // Update period timer
        function updatePeriodTimer() {
            clearInterval(currentPeriodTimer);
            
            let seconds = 60;
            
            currentPeriodTimer = setInterval(() => {
                seconds--;
                if (seconds < 0) {
                    seconds = 60;
                    updatePeriod(); // Refresh period
                }
                
                document.getElementById('period-timer').textContent = 
                    `Next update in: ${seconds}s`;
            }, 1000);
        }
        
        // Generate prediction
        async function generatePrediction() {
            // Check if user has enough coins
            if (coins < 5) {
                alert("Not enough coins! Please buy more coins.");
                return;
            }
            
            // Check if already predicted for this period
            if (lastPredictionPeriod === currentPeriodNumber) {
                alert("You can only generate one prediction per period!");
                return;
            }
            
            // Check if period is valid
            if (!currentPeriodNumber || currentPeriodNumber === "LOADING...") {
                alert("Please wait for period number to load!");
                return;
            }
            
            // Disable generate button during processing
            const generateBtn = document.getElementById('generate-btn');
            generateBtn.disabled = true;
            
            // Deduct coins
            coins -= 5;
            localStorage.setItem('wingo_coins', coins);
            document.getElementById('available-coins').textContent = coins;
            
            // Update coins in Firebase
            await updateCoinsInFirebase(coins);
            
            // Mark this period as predicted
            lastPredictionPeriod = currentPeriodNumber;
            
            // Show analysis animation
            const analysisContainer = document.getElementById('analysis-container');
            const predictionResult = document.getElementById('prediction-result');
            const progressBar = document.getElementById('progress-bar');
            
            analysisContainer.style.display = 'block';
            predictionResult.style.display = 'none';
            
            // Reset and start progress bar
            progressBar.style.width = '0%';
            setTimeout(() => {
                progressBar.style.width = '100%';
            }, 10);
            
            // Generate Unix terminal analysis
            generatePatternAnalysis();
            
            // Generate graph animation
            generatePatternGraph();
            
            // Wait 5 seconds for animation
            setTimeout(async () => {
                // Fetch latest data
                await fetchData();
                
                // Detect pattern and generate prediction
                const patternInfo = detectPattern();
                const prediction = patternInfo.prediction;
                
                // Display the prediction
                displayPrediction(prediction, patternInfo.type);
                
                // Save prediction to history as PENDING
                savePredictionToHistory(prediction, patternInfo.type);
                
                // Hide analysis, show result
                analysisContainer.style.display = 'none';
                predictionResult.style.display = 'block';
                
                // Re-enable generate button
                generateBtn.disabled = false;
            }, 5000);
        }
        
        // Generate pattern analysis for terminal
        function generatePatternAnalysis() {
            const analysisText = document.getElementById('analysis-text');
            const patternInfo = detectPattern();
            
            const terminalLines = [
                "> Connecting to Wingo API... OK",
                "> Fetching last 15 results... OK",
                "> Analyzing size patterns...",
                "> Analyzing color patterns...",
                "> Detected pattern: " + (patternInfo.pattern ? patternInfo.pattern.name : "No clear pattern"),
                "> Pattern confidence: " + Math.round(patternInfo.confidence) + "%",
                "> Current mode: " + currentMode.toUpperCase(),
                "> Pattern description: " + patternInfo.description,
                "> Generating prediction...",
                "> Prediction ready!"
            ];
            
            let text = "";
            let index = 0;
            
            const interval = setInterval(() => {
                if (index < terminalLines.length) {
                    text += terminalLines[index] + "<br>";
                    analysisText.innerHTML = text;
                    index++;
                } else {
                    clearInterval(interval);
                }
            }, 400);
        }
        
        // Generate pattern graph
        function generatePatternGraph() {
            const graphCanvas = document.getElementById('graph-canvas');
            graphCanvas.innerHTML = '';
            
            // Create graph axis
            const axis = document.createElement('div');
            axis.className = 'graph-line';
            graphCanvas.appendChild(axis);
            
            // Create animated points for trend
            const pointCount = 12;
            const points = [];
            let lastY = 50;
            
            for (let i = 0; i < pointCount; i++) {
                const point = document.createElement('div');
                point.className = 'graph-point';
                
                const x = (i / (pointCount - 1)) * 100;
                
                // Create trending pattern based on current pattern
                let y;
                if (i === 0) {
                    y = 50;
                } else {
                    // Create pattern-like movement
                    if (currentPattern && currentPattern.name.includes('STRAIGHT')) {
                        // Straight trend - minimal movement
                        const change = Math.random() * 10 + 5;
                        y = Math.max(30, Math.min(70, lastY + (Math.random() > 0.5 ? change : -change)));
                    } else if (currentPattern && currentPattern.name.includes('ALTERNATING')) {
                        // Alternating pattern
                        y = i % 2 === 0 ? 30 : 70;
                    } else {
                        // Random pattern
                        const trend = Math.random() > 0.5 ? 1 : -1;
                        const change = Math.random() * 20 + 10;
                        y = Math.max(10, Math.min(90, lastY + (change * trend)));
                    }
                }
                lastY = y;
                
                point.style.left = `${x}%`;
                point.style.bottom = `${y}%`;
                
                // Animate point with delay
                point.style.animation = `pointPulse ${Math.random() * 0.5 + 0.5}s infinite alternate`;
                point.style.animationDelay = `${i * 0.2}s`;
                
                graphCanvas.appendChild(point);
                points.push(point);
                
                // Connect points with lines
                if (i > 0) {
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.height = '1px';
                    line.style.background = 'var(--matrix-green)';
                    line.style.boxShadow = '0 0 5px var(--matrix-green)';
                    
                    const prevX = ((i-1) / (pointCount - 1)) * 100;
                    const prevY = points[i-1].style.bottom;
                    
                    const x1 = `calc(${prevX}% + 3px)`;
                    const y1 = prevY;
                    const x2 = `calc(${x}% - 3px)`;
                    const y2 = `${y}%`;
                    
                    const distance = Math.sqrt(Math.pow(parseFloat(x) - parseFloat(prevX), 2) + Math.pow(y - parseFloat(prevY.replace('%', '')), 2));
                    const angle = Math.atan2(y - parseFloat(prevY.replace('%', '')), parseFloat(x) - parseFloat(prevX)) * 180 / Math.PI;
                    
                    line.style.width = `${distance}%`;
                    line.style.left = x1;
                    line.style.bottom = y1;
                    line.style.transformOrigin = '0 0';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.opacity = '0.7';
                    
                    graphCanvas.appendChild(line);
                }
            }
            
            // Add CSS for point animation if not exists
            if (!document.querySelector('#graphAnimations')) {
                const style = document.createElement('style');
                style.id = 'graphAnimations';
                style.textContent = `
                    @keyframes pointPulse {
                        0% { transform: translate(-50%, 50%) scale(1); opacity: 0.7; }
                        100% { transform: translate(-50%, 50%) scale(1.5); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Display prediction
        function displayPrediction(prediction, type) {
            const predictionValue = document.getElementById('prediction-value');
            const predictionType = document.getElementById('prediction-type');
            
            predictionValue.textContent = prediction;
            predictionType.textContent = type.toUpperCase() + " PREDICTION";
            
            // Set color based on prediction value
            predictionValue.className = 'prediction-value';
            
            if (type === 'color') {
                if (prediction === 'RED') {
                    predictionValue.classList.add('prediction-red');
                } else if (prediction === 'GREEN') {
                    predictionValue.classList.add('prediction-green');
                }
            } else {
                if (prediction === 'BIG') {
                    predictionValue.classList.add('prediction-big');
                } else {
                    predictionValue.classList.add('prediction-small');
                }
            }
        }
        
        // Save prediction to history
        function savePredictionToHistory(prediction, type) {
            const historyItem = {
                period: currentPeriodNumber,
                prediction: prediction,
                type: type,
                timestamp: Date.now(),
                status: 'PENDING',
                pattern: currentPattern ? currentPattern.name : 'RANDOM',
                confidence: Math.round(patternConfidence)
            };
            
            // Check if prediction already exists for this period
            const existingIndex = historyData.findIndex(item => item.period === currentPeriodNumber);
            if (existingIndex !== -1) {
                historyData[existingIndex] = historyItem;
            } else {
                historyData.unshift(historyItem);
            }
            
            // Keep only last 20 predictions
            if (historyData.length > 20) {
                historyData = historyData.slice(0, 20);
            }
            
            localStorage.setItem('wingo_history', JSON.stringify(historyData));
            
            // Update history display
            updateHistoryDisplay();
        }
        
        // Process pending results - FIXED WIN/LOSS LOGIC
        function processPendingResults() {
            if (historyData.length === 0) return;
            
            // Get previous period
            const previousPeriod = (BigInt(currentPeriodNumber) - 1n).toString();
            
            // Find pending prediction for previous period
            const pendingItem = historyData.find(item => 
                item.status === 'PENDING' && item.period === previousPeriod
            );
            
            if (!pendingItem) return;
            
            // Find the actual result for this period
            const actualResult = resultsData.find(item => item.issueNumber === previousPeriod);
            
            if (actualResult) {
                const actualNum = parseInt(actualResult.number);
                const actualColor = getColorFromNumber(actualNum);
                const actualSize = getSizeFromNumber(actualNum);
                
                // Determine if prediction was correct using the fixed logic
                let isWin = false;
                
                if (pendingItem.type === 'color') {
                    isWin = (pendingItem.prediction === actualColor);
                    console.log(`Color Prediction Check: Prediction=${pendingItem.prediction}, Actual=${actualColor}, Result=${actualNum}, Win=${isWin}`);
                } else { // size
                    isWin = (pendingItem.prediction === actualSize);
                    console.log(`Size Prediction Check: Prediction=${pendingItem.prediction}, Actual=${actualSize}, Result=${actualNum}, Win=${isWin}`);
                }
                
                // Update history item
                pendingItem.status = isWin ? 'WIN' : 'LOSS';
                pendingItem.actualResult = `${actualNum} (${actualSize}/${actualColor})`;
                pendingItem.processedAt = Date.now();
                
                // Update streaks
                if (isWin) {
                    winStreak++;
                    lossStreak = 0;
                    consecutiveWins++;
                    
                    console.log(`WIN! Consecutive wins: ${consecutiveWins}`);
                    
                    // Play win streak popup if it's a win
                    if (consecutiveWins >= 1) {
                        console.log('Attempting to show win popup...');
                        
                        // Show popup after a short delay
                        setTimeout(() => {
                            playWinStreakPopup();
                        }, 1000);
                    }
                } else {
                    lossStreak++;
                    winStreak = 0;
                    consecutiveWins = 0;
                    console.log('LOSS! Reset consecutive wins to 0');
                }
                
                // Update stats
                totalPredictions++;
                if (isWin) correctPredictions++;
                
                // Save updated history
                localStorage.setItem('wingo_history', JSON.stringify(historyData));
                
                // Update history display
                updateHistoryDisplay();
                
                // Show detailed result in console for debugging
                console.log(`Result Details: Period ${previousPeriod}, Number ${actualNum}, Color ${actualColor}, Size ${actualSize}, Prediction ${pendingItem.prediction} (${pendingItem.type}), Win: ${isWin}`);
            } else {
                console.log(`No actual result found for period ${previousPeriod}`);
            }
        }
        
        // Load history from localStorage
        function loadHistory() {
            const savedHistory = localStorage.getItem('wingo_history');
            if (savedHistory) {
                historyData = JSON.parse(savedHistory);
                
                // Calculate consecutive wins from history
                consecutiveWins = 0;
                for (let i = 0; i < Math.min(5, historyData.length); i++) {
                    if (historyData[i].status === 'WIN') {
                        consecutiveWins++;
                    } else {
                        break;
                    }
                }
                
                updateHistoryDisplay();
            }
        }
        
        // Update history display
        function updateHistoryDisplay() {
            const historyItems = document.getElementById('history-items');
            historyItems.innerHTML = '';
            
            if (historyData.length === 0) {
                historyItems.innerHTML = '<div class="no-prediction">No predictions yet. Generate your first prediction!</div>';
                return;
            }
            
            // Show last 10 history items
            const recentHistory = historyData.slice(0, 10);
            
            recentHistory.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                const resultClass = item.status === 'WIN' ? 'win' : 
                                  item.status === 'LOSS' ? 'loss' : 'pending';
                
                const resultText = item.status === 'PENDING' ? 'Pending' : 
                                 item.status === 'WIN' ? 'WIN' : 'LOSS';
                
                // Shorten period number for display
                const shortPeriod = item.period.length > 10 ? 
                    item.period.substring(item.period.length - 8) : item.period;
                
                historyItem.innerHTML = `
                    <div class="history-period">Period ${shortPeriod}</div>
                    <div class="history-prediction">${item.prediction}</div>
                    <div class="history-result ${resultClass}">${resultText}</div>
                `;
                
                historyItems.appendChild(historyItem);
            });
        }
        
        // Initialize on page load
        window.onload = function() {
            userId = generateUserId();
            userUid = generateUid();
            initializeEffects();
            
            // Check if user has already scratched before
            hasScratchedBefore = localStorage.getItem('wingo_has_scratched') === 'true';
            
            // If user has coins and has scratched before, go directly to prediction page
            const savedCoins = localStorage.getItem('wingo_coins');
            if (savedCoins && parseInt(savedCoins) > 0 && hasScratchedBefore) {
                coins = parseInt(savedCoins);
                // Don't go directly to prediction page - user must select platform first
                // Show landing page to select platform
                document.getElementById('landing-page').style.display = 'flex';
            } else {
                // Show landing page to select platform
                document.getElementById('landing-page').style.display = 'flex';
            }
        };
        
        // Regenerate matrix columns on resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                document.getElementById('matrix-bg').innerHTML = '';
                createMatrixRain();
            }, 250);
        });
    </script>
</body>
</html>